<?xml version="1.0" encoding="utf-8"?>
<mx:WindowedApplication xmlns:mx="http://www.adobe.com/2006/mxml" 
						xmlns:ui="com.swfwire.debugger.ui.*"
						showStatusBar="false"
						applicationComplete="main()"
						minWidth="400" minHeight="300"
						paddingLeft="5" paddingTop="5"
						paddingRight="5" paddingBottom="5"
						horizontalAlign="right"
						currentState="waiting" backgroundColor="#222222">
	<mx:Style source="../assets/style.css"/>
	<mx:Script>
		<![CDATA[
			import air.update.ApplicationUpdaterUI;
			import air.update.events.UpdateEvent;
			
			import com.swfwire.debugger.Config;
			import com.swfwire.debugger.DebuggerAsyncModifier;
			import com.swfwire.debugger.debug;
			import com.swfwire.debugger.ui.PreviewWindow;
			import com.swfwire.debugger.utils.*;
			import com.swfwire.decompiler.*;
			import com.swfwire.decompiler.abc.ABCReaderMetadata;
			import com.swfwire.decompiler.abc.instructions.*;
			import com.swfwire.decompiler.abc.tokens.*;
			import com.swfwire.decompiler.data.swf.SWF;
			import com.swfwire.decompiler.data.swf.SWFHeader;
			import com.swfwire.decompiler.data.swf.tags.SWFTag;
			import com.swfwire.decompiler.data.swf8.tags.FileAttributesTag;
			import com.swfwire.decompiler.events.AsyncSWFModifierEvent;
			import com.swfwire.decompiler.events.AsyncSWFReaderEvent;
			import com.swfwire.decompiler.events.AsyncSWFWriterEvent;
			import com.swfwire.utils.ArrayUtil;
			import com.swfwire.utils.Debug;
			import com.swfwire.utils.ObjectUtil;
			import com.swfwire.utils.air.WindowTracker;
			
			import flash.utils.getQualifiedClassName;
			import flash.utils.getTimer;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.controls.TextInput;
			import mx.core.IUIComponent;
			import mx.core.UIComponent;
			import mx.events.DynamicEvent;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			import mx.events.NumericStepperEvent;
			import mx.graphics.codec.PNGEncoder;
			import mx.managers.DragManager;
			
			private var windowTracker:WindowTracker;
			private var appUpdater:ApplicationUpdaterUI;
			private var urlLoader:URLLoader;
			
			private var logger:*;
			private var injectedAppDomain:ApplicationDomain;
			private var lastUrl:String;
			private var isCached:Boolean;
			private var netObjects:Dictionary = new Dictionary(true);
			private var currentFrameRate:Number = 0;
			private var lastFrameRateUpdate:int = 0;
			private var frameCount:int = 0;
			
			private var sanityCheck:Boolean = false;
			
			private var preview:PreviewWindow = new PreviewWindow();
			private var injectionLoader:Loader;
			
			private var propertiesCollection:ArrayCollection = new ArrayCollection();
			private var methodsCollection:ArrayCollection = new ArrayCollection();
			private var stylesCollection:ArrayCollection = new ArrayCollection();
			private var netCollection:ArrayCollection = new ArrayCollection();
			private var objectCollection:ArrayCollection = new ArrayCollection();
			
			private var lastTarget:DisplayObject;
			private var lastInspectTarget:Object;
			private var lastHits:Array = [];
			
			private var lastFileSize:uint;
			private var lastRunBytes:ByteArray;
			private var updateStatsTimer:Timer;
			private var swfId:int = 1;
			
			private function main():void
			{
				debug = new Debug(true, 'SWFWireDebugger');
				debug.log('main');
				
				contextMenu.items.push(new ContextMenuItem('SWFWireDebugger Version '+Config.VERSION));
				
				stage.addEventListener(Event.ENTER_FRAME, enterFrameHandler);
				
				addEventListener(Event.CLOSE, function(ev:Event):void
				{
					preview.visible = true;
					preview.close();
				});
				
				preview.visible = false;
				preview.addEventListener(Event.CLOSING, function(ev:Event):void
				{
					if(!nativeWindow.closed)
					{
						ev.preventDefault();
						objectCollection.removeAll();
						preview.unload();
						preview.visible = false;
						currentState = 'waiting';
					}
				});
				preview.alwaysInFront = true;
				
				appUpdater = new ApplicationUpdaterUI();
				appUpdater.configurationFile = new File('app:/updateConfig.xml');
				if(Config.TESTING)
				{
					appUpdater.addEventListener(UpdateEvent.INITIALIZED, function(ev:Event):void
					{
						appUpdater.checkNow();
					});
				}

				appUpdater.initialize();
				
				windowTracker = new WindowTracker(SharedObject.getLocal('preferences'), nativeWindow);
				windowTracker.restore();
				windowTracker.startTracking();
				
				urlLoader = new URLLoader();
				urlLoader.addEventListener(ProgressEvent.PROGRESS,	 loadProgressHandler);
				urlLoader.addEventListener(Event.COMPLETE,			 loadCompleteHandler);
				urlLoader.dataFormat = URLLoaderDataFormat.BINARY;
				
				swfDropTarget.addEventListener(NativeDragEvent.NATIVE_DRAG_ENTER,	 dragEnterHandler);
				swfDropTarget.addEventListener(NativeDragEvent.NATIVE_DRAG_DROP,	 dragDropHandler);
				
				preview.stage.addEventListener(MouseEvent.MIDDLE_MOUSE_DOWN, previewMiddleDownHandler, true, int.MAX_VALUE, true);
				
				loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, function(ev:UncaughtErrorEvent):void
				{
					ev.preventDefault();
					ev.stopPropagation();
					ev.stopImmediatePropagation();
					logger.uncaughtError(ev.error);
					log('Uncaught error in root.');
					log(ObjectUtil.objectToString(ev.error, 2, 2, 50, 50, true, '	'));
				});
				
				preview.loader.contentLoaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, function(ev:UncaughtErrorEvent):void
				{
					ev.preventDefault();
					ev.stopPropagation();
					ev.stopImmediatePropagation();
					logger.uncaughtError(ev.error);
					log('Uncaught error in child.');
					log(ObjectUtil.objectToString(ev.error, 2, 2, 50, 50, true, '	'));
				});
				
				preview.addEventListener('loaderComplete', function(ev:Event):void
				{
					updateStatus('Successfully loaded '+lastUrl);
					
					preview.visible = true;
					preview.activate();
					
					var loaderClass:* = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.Loader');
					loaderClass.overrideApplicationDomain = preview.loader.contentLoaderInfo.applicationDomain;
					
					var urlLoaderClass:* = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.URLLoader');
					urlLoaderClass.applicationRoot = lastUrl.substr(0, lastUrl.lastIndexOf('/') + 1);
					urlLoaderClass.referer = lastUrl;
					
					var stageClass:* = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.SWFWire_Stage');
					stageClass.stage = preview.stage;
					
					var loaderInfoClass:* = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.SWFWire_LoaderInfo');
					//loaderInfoClass.defaultParameters = parameters;
					
					//loaderClass.overrideApplicationDomain = new ApplicationDomain(preview.loader.contentLoaderInfo.applicationDomain);
					
					/*
					if(rootSWF)
					{
						var RootClass:* = injectedAppDomain.getDefinition(rootClassName);
						var rootInstance:* = new RootClass();
					}
					*/
					
					var target:DisplayObject = preview.loader.content;
					
					logger.newObject(target);
					inspect(target);
					var name:String = getQualifiedClassName(target);
					name = name.split('::').pop();
					breadCrumb.collection.addItem({name: name, reference: target});
				});
				
				var context:LoaderContext = new LoaderContext();
				context.applicationDomain = new ApplicationDomain();
				context.allowCodeImport = true;
				
				injectionLoader = new Loader();
				injectionLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(ev:*):void
				{
					injectedAppDomain = injectionLoader.contentLoaderInfo.applicationDomain;
					
					console.text += 'Injection loaded\n';
					
					logger = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.Logger');
					logger.output = console;
					
					logToTrace.selected = logger.logToTrace;
					logToOutput.selected = logger.logToOutput;
					logToTrace.selected = logger.logToTrace;
					showMethodEntry.selected = logger.showMethodEntry;
					showMethodExit.selected = logger.showMethodExit;
					showTrace.selected = logger.showTraceStatements;
					dumpArguments.selected = logger.showArguments;
					showReturn.selected = logger.showReturn;
					showObjectCreation.selected = logger.showObjectCreation;
					skipEnterFrame.selected = logger.skipEnterFrame;
					skipExitFrame.selected = logger.skipExitFrame;
					skipRender.selected = logger.skipRender;
					skipFrameConstructed.selected = logger.skipFrameConstructed;
					skipTimer.selected = logger.skipTimer;
					maxStackDepth.value = logger.maxStack;
					
					var loaderClass:* = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.Loader');
					loaderClass.globalEvents.addEventListener('loadComplete', function(ev:*):void
					{
						var data:ByteArray = ev.data as ByteArray;
						ev.instance.loadBytes(data);
						var signature:String;
						if(data.length >= 4)
						{
							var startPosition:uint = data.position;
							data.position = 0;
							signature = data.readUTFBytes(3);
							data.position = startPosition;
						}
						if(signature == 'FWS' || signature == 'CWS')
						{
							log('[SWF] '+ev.request.url+' - Load complete');
						}
					});
					loaderClass.globalEvents.addEventListener('loadBytes', function(ev:*):void
					{
						var data:ByteArray = ev.bytes as ByteArray;
						var signature:String;
						if(data.length >= 4)
						{
							var startPosition:uint = data.position;
							data.position = 0;
							signature = data.readUTFBytes(3);
							data.position = startPosition;
						}
						
						if(signature == 'FWS' || signature == 'CWS')
						{
							save(data, lastUrl+'.loaded.'+(new Date().getTime())+'.swf');
							
							if(modifyChildren.selected)
							{
								read(ev.bytes, ev.context, ev.instance, swfId++);
							}
							else
							{
								ev.instance['swfWire_loadBytes'](ev.bytes, ev.context);
							}
						}
						else
						{
							ev.instance['swfWire_loadBytes'](ev.bytes, ev.context);
						}
					});
					
					var urlLoaderClass:* = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.URLLoader');
					urlLoaderClass.globalEvents.addEventListener(Event.OPEN, function(ev:*):void
					{
						logToNet(ev.instance, ev.url, 'open');
					});
					urlLoaderClass.globalEvents.addEventListener(ProgressEvent.PROGRESS, function(ev:*):void
					{
						logToNet(ev.instance, ev.url, 'progress');
					});
					urlLoaderClass.globalEvents.addEventListener(Event.COMPLETE, function(ev:*):void
					{
						logToNet(ev.instance, ev.url, 'complete');
					});
					urlLoaderClass.globalEvents.addEventListener(Event.CLOSE, function(ev:*):void
					{
						logToNet(ev.instance, ev.url, 'close');
					});
					urlLoaderClass.globalEvents.addEventListener(IOErrorEvent.IO_ERROR, function(ev:*):void
					{
						logToNet(ev.instance, ev.url, 'ioError');
					});
					urlLoaderClass.globalEvents.addEventListener(SecurityErrorEvent.SECURITY_ERROR, function(ev:*):void
					{
						logToNet(ev.instance, ev.url, 'securityError');
					});
					
					var ncClass:* = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.NetConnection');
					ncClass.globalEvents.addEventListener('connect', function(ev:*):void
					{
						//logToNet(ev.command+': rtmp connect');
					});
					ncClass.globalEvents.addEventListener('call', function(ev:*):void
					{
						//logToNet(ev.command+': rtmp call');
					});
					ncClass.globalEvents.addEventListener('close', function(ev:*):void
					{
						//logToNet(ev.command+': rtmp close');
					});
					
					var socketClass:* = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.Socket');
					socketClass.globalEvents.addEventListener('swfWireConnect', function(ev:*):void
					{
						//logToNet(ev.host+':'+ev.port+': socket connect');
					});
					socketClass.globalEvents.addEventListener('swfWireClose', function(ev:*):void
					{
						//logToNet(ev.host+':'+ev.port+': socket closed by client');
					});
					socketClass.globalEvents.addEventListener(Event.CONNECT, function(ev:*):void
					{
						//logToNet(ev.host+':'+ev.port+': socket connected');
					});
					socketClass.globalEvents.addEventListener(ProgressEvent.SOCKET_DATA, function(ev:*):void
					{
						//logToNet(ev.host+':'+ev.port+': socket data: '+ev.instance.bytesAvailable);
					});
					socketClass.globalEvents.addEventListener(IOErrorEvent.IO_ERROR, function(ev:*):void
					{
						//logToNet(ev.host+':'+ev.port+': socket ioerror');
					});
					socketClass.globalEvents.addEventListener(SecurityErrorEvent.SECURITY_ERROR, function(ev:*):void
					{
						//logToNet(ev.host+':'+ev.port+': socket security error');
					});
					socketClass.globalEvents.addEventListener(Event.CLOSE, function(ev:*):void
					{
						//logToNet(ev.host+':'+ev.port+': socket closed by server');
					});
					
					var globals:* = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.Globals');
					globals.stage = preview.stage;
				});
				
				var librarySwf:String = 'app:/library.swf';
				
				publicPropertiesGrid.dataProvider = propertiesCollection;
				publicMethodsGrid.dataProvider = methodsCollection;
				stylesGrid.dataProvider = stylesCollection;
				netList.dataProvider = netCollection;
				objectList.dataProvider = objectCollection;
				
				publicPropertiesGrid.addEventListener('inspectProperty', function(ev:*):void
				{
					inspect(ev.info);
				});
				publicPropertiesGrid.addEventListener('editProperty', function(ev:*):void
				{
					var info:* = ev.info;
					var success:Boolean = true;
					try
					{
						lastInspectTarget[info.name] = ev.value;
					}
					catch(e:*)
					{
						var description:XML = describeType(lastInspectTarget);
						var setPropertyMethod:String = 'swfWire_setProperty_'+String(description.@name);
						try
						{
							success = lastInspectTarget[setPropertyMethod](info.name, ev.value);
						}
						catch(e2:ReferenceError)
						{
							success = false;
							console.text += 'Error setting property: '+e+'\n';
							updateStatus('Error setting property (#'+e.errorID+').');
						}
						catch(e:*)
						{
							success = false;
							console.text += 'Error setting property: '+e+'\n';
							updateStatus('Error setting property (#'+e.errorID+').');
						}
					}
					ev.success = success;
				});
				
				stylesGrid.addEventListener('editProperty', function(ev:*):void
				{
					var info:* = ev.info;
					var success:Boolean = true;
					try
					{
						lastInspectTarget.setStyle(info.name, ev.value);
					}
					catch(e:Error)
					{
						success = false;
						log('Error setting style: '+e);
						updateStatus('Error setting style (#'+e.errorID+').');
					}
					ev.success = success;
				});
				
				breadCrumb.addEventListener('breadCrumbClick', function(ev:DynamicEvent):void
				{
					inspect(ev.data);
				});
				breadCrumb.addEventListener('breadCrumbRollOver', function(ev:DynamicEvent):void
				{
					preview.highlight(ev.data);
				});
				breadCrumb.addEventListener('breadCrumbRollOut', function(ev:DynamicEvent):void
				{
					preview.highlight(null);
				});
				
				objectCollection.filterFunction = objectFilter;
				
				injectionLoader.load(new URLRequest(librarySwf), context);
			}
			
			private function objectFilter(item:Object):Boolean 
			{
				var match:Boolean = true;
				if(item)
				{
					var re:RegExp = new RegExp(objectListSearch.text, 'i');
					if(item.type)
					{
						match = (item.type.search(re) != -1)
					}
					if(!match && item.method)
					{
						match = (item.method.search(re) != -1);
					}
				}
				return match;
			}
			
			private function previewMiddleDownHandler(ev:MouseEvent):void
			{
				stopInspection();
			}
			
			private function inspect_mouseMoveHandler(ev:MouseEvent):void
			{
				var point:Point = new Point(preview.stage.mouseX, preview.stage.mouseY);
				var hits:Array = preview.stage.getObjectsUnderPoint(point);
				hits.unshift(preview.loader.content);
				
				var changed:Boolean = !ArrayUtil.compare(hits, lastHits);
				
				if(changed)
				{
					var path:Array = [];
					
					preview.highlight(null);
					
					var target:DisplayObject;
					var rect:Rectangle;
					
					breadCrumb.collection.removeAll();
					
					for(var iter:int = 0; iter < hits.length; iter++)
					{
						target = hits[iter];
						if(preview.loader.contains(target))
						{
							preview.highlight(target, false);
							var name:String = getQualifiedClassName(target);
							name = name.split('::').pop();
							breadCrumb.collection.addItem({name: name, reference: target});
						}
					}
					
					breadCrumb.collection.refresh();
					lastHits = hits;
				}
			}
			
			protected function inspect(target:Object):void
			{
				propertiesCollection.removeAll();
				methodsCollection.removeAll();
				stylesCollection.removeAll();
				
				var description:XML = describeType(target);
				var node:XML;
				var name:String;
				var key:*;
				var value:*;
				
				var properties:Array = [];
				
				for each(node in description.variable)
				{
					var q:QName = new QName(node.@uri, node.@name);
					properties.push({namespace: 'public', access: 'variable', label: 'Public Variable', name: String(q), value: target[q]});
				}
				
				for each(node in description.accessor)
				{
					var access:* = node.@access;
					name = node.@name;
					try
					{
						value = target[name];
					}
					catch(e:*)
					{
						value = '<exception thrown by getter>';
					}
					properties.push({namespace: 'public', access: access, label: 'Public '+access, name: name, value: value});
				}
				
				try
				{
					var hierarchy:Array = [description.@name];
					for each(var superClass:String in description.extendsClass.@type)
					{
						hierarchy.push(superClass);
					}
					for(var iter:int = 0; iter < hierarchy.length; iter++)
					{
						var className:String = hierarchy[iter];
						var propertiesMethod:String = 'swfWire_enumerateProperties_'+className;
						var privateProperties:Object = target[propertiesMethod]();
						for(name in privateProperties)
						{
							properties.push({namespace: 'private', access: 'variable', label: 'Private', name: name, value: privateProperties[name]});
						}
					}
				}
				catch(e:*){}
				
				for(key in target)
				{
					properties.push({namespace: 'dynamic', access: 'variable', label: 'Dynamic', name: key, value: target[key]});
				}
				
				properties.sortOn(['namespace', 'name']);
				
				var methods:Array = [];
				
				try
				{
					var methodsMethod:String = 'swfWire_enumerateMethods_'+String(description.@name);
					var privateMethods:Object = target[methodsMethod]();
					for(name in privateMethods)
					{
						methods.push({namespace: 'private', name: name});
					}
				}
				catch(e:*){}
				
				var hasGetStyle:Boolean = false;
				
				for each(node in description.method)
				{
					name = node.@name;
					if(name.substr(0, 8) == 'swfWire_')
					{
						continue;
					}
					if(name == 'getStyle')
					{
						hasGetStyle = true;
					}
					methods.push({namespace: 'public', name: name});
				}
				
				methods.sortOn(['namespace', 'name']);
				
				if(hasGetStyle)
				{
					if(stylesCanvas.parent != inspectTabs)
					{
						inspectTabs.addChild(stylesCanvas);
					}

					var factoryStyles:Object = {};
					try
					{
						target.styleDeclaration.defaultFactory.apply(factoryStyles);
					}
					catch(e:*){}
					try
					{
						target.styleDeclaration.factory.apply(factoryStyles);
					}
					catch(e:*){}
					
					for(name in factoryStyles)
					{
						value = null;
						try
						{
							value = target.getStyle(name);
						}
						catch(e:*){}
						stylesCollection.addItem({name: name, value: value});
					}
					
					var styleNames:Array = ['left', 'top', 'right', 'bottom', 'horizontalCenter', 'verticalCenter',
						'paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop', 'horizontalGap', 'verticalGap',
						'backgroundAlpha', 'backgroundColor', 'contentBackgroundAlpha', 'contentBackgroundColor',
						'baseline', 'color', 'direction', 'disabledColor', 'errorColor', 'focusAlpha', 'focusBlendMode',
						'focusRoundedCorners', 'focusThickness', 'fontAntiAliasType', 'fontFamily', 'fontGridFitType',
						'fontSharpness', 'fontSize', 'fontStyle', 'fontThickness', 'fontWeight', 'interactionMode',
						'kerning', 'layoutDirection', 'leading', 'letterSpacing', 'textAlign', 'textDecoration',
						'textFieldClass', 'textIndent', 'textRollOverColor', 'textSelectedColor'];
					
					for each(name in styleNames)
					{
						if(factoryStyles.hasOwnProperty(name))
						{
							continue;
						}
						value = null;
						try
						{
							value = target.getStyle(name);
						}
						catch(e:*){}
						stylesCollection.addItem({name: name, value: value});
					}
				}
				else
				{
					if(stylesCanvas.parent == inspectTabs)
					{
						inspectTabs.removeChild(stylesCanvas);
					}
				}
				
				propertiesCollection.source = properties;
				methodsCollection.source = methods;
				
				var objectData:Object = logger.getObjectData(target);
				
				if(objectData)
				{
					var method:String = objectData.method ? ' in ' + objectData.method : '';
					inspectType.text = '#' + objectData.id + '  ' + description.@name + ' created' + method + ' at ' + objectData.creationTime + 'ms';
				}
				else
				{
					inspectType.text = description.@name;
				}
				
				lastInspectTarget = target;
			}
			
			private function loadProgressHandler(ev:ProgressEvent):void
			{
				loadProgress.setProgress(ev.bytesLoaded, ev.bytesTotal);
			}
			
			private function loadCompleteHandler(ev:Event):void
			{
				var bytes:ByteArray = urlLoader.data as ByteArray;
				if(bytes)
				{
					if(isCached || sanityCheck)
					{
						readProgress.setProgress(1, 1);
						modifyProgress.setProgress(1, 1);
						writeProgress.setProgress(1, 1);
						run(bytes);
					}
					else
					{
						read(bytes);
					}
				}
			}
			
			private function dragEnterHandler(ev:NativeDragEvent):void
			{
				DragManager.acceptDragDrop(IUIComponent(ev.currentTarget));
			}
			
			private function dragDropHandler(ev:NativeDragEvent):void
			{
				var clipboard:Clipboard = ev.clipboard;
				var url:String = '';
				if(clipboard.hasFormat(ClipboardFormats.URL_FORMAT))
				{
					url = clipboard.getData(ClipboardFormats.URL_FORMAT) as String;
				}
				else if(clipboard.hasFormat(ClipboardFormats.TEXT_FORMAT))
				{
					url = clipboard.getData(ClipboardFormats.TEXT_FORMAT) as String;
				}
				else if(clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
				{
					var files:Array = clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array;
					var file:File = files[0];
					if(file)
					{
						url = file.url;
					}
				}
				if(url)
				{
					swfUrl.text = url;
				}
				else
				{
					Alert.show('Could not parse any valid SWF file from the drop.', 'No data');
				}
			}
			
			public function load(url:String):void
			{
				log('Attempting to load: '+url);
				
				lastUrl = url;
				
				var recompiledFileUrl:String = url+'.recompiled.0.swf';
				var recompiledFile:File = File.applicationDirectory.resolvePath(recompiledFileUrl);
				if(recompiledFile.exists && useCached.selected)
				{
					url = recompiledFileUrl;
					isCached = true;
				}
				else
				{
					isCached = false;
				}
				
				log('Loading: '+url);
				
				loadProgress.setProgress(0, 0);
				readProgress.setProgress(0, 0);
				writeProgress.setProgress(0, 0);
				
				var swfName:String = lastUrl.substr(lastUrl.lastIndexOf('/') + 1);
				
				preview.title = swfName;
				
				currentState = 'loading';
				
				urlLoader.load(new URLRequest(url));
			}
			
			private function read(bytes:ByteArray, context:LoaderContext = null, instance:Loader = null, swfId:int = -1):void
			{
				var start:uint = getTimer();
				
				var swfBytes:SWFByteArray = new SWFByteArray(bytes);
				var swfReader:AsyncSWFReaderFiltered = new AsyncSWFReaderFiltered();
				var result:SWFReadResult;
				
				swfReader.includedTags[0] = true;
				swfReader.includedTags[9] = true;
				swfReader.includedTags[69] = true;
				swfReader.includedTags[76] = true;
				swfReader.includedTags[82] = true;
				if(!instance)
				{
					currentState = 'reading';
					swfReader.addEventListener(AsyncSWFReaderEvent.TAG_READ, function(ev:AsyncSWFReaderEvent):void
					{
						var current:uint = ev.context.bytes.getBytePosition();
						var max:uint = ev.context.bytes.getLength();
						readProgress.setProgress(current, max);
					});
				}
				swfReader.addEventListener(AsyncSWFReaderEvent.READ_COMPLETE, function(ev:AsyncSWFReaderEvent):void
				{
					var diff:uint = getTimer() - start;
					log('Reading swf took: '+diff+'ms');

					modify(ev.result.swf, ev.result.abcMetadata, context, instance, swfId);
				});
				
				result = swfReader.read(swfBytes);
			}
			
			private function modify(swf:SWF, metadata:Vector.<ABCReaderMetadata>, context:LoaderContext = null,
									instance:Loader = null, swfId:int = -1):void
			{
				var start:uint = getTimer();
				
				swf.header.signature = SWFHeader.UNCOMPRESSED_SIGNATURE;
				
				var shouldModify:Boolean = false;
				
				if(swf.header.fileVersion >= 9)
				{
					for each(var iter:SWFTag in swf.tags)
					{
						var fileAttributes:FileAttributesTag = iter as FileAttributesTag;
						if(fileAttributes && fileAttributes.actionScript3)
						{
							shouldModify = true;
							break;
						}
					}
				}
				
				if(shouldModify)
				{
					var modifier:DebuggerAsyncModifier = new DebuggerAsyncModifier(swf, metadata, instance == null);
					
					if(!instance)
					{
						currentState = 'modifying';
						
						modifier.addEventListener(AsyncSWFModifierEvent.RUN, function(ev:AsyncSWFModifierEvent):void
						{
							modifyProgress.setProgress(ev.progress, 1);
						});
					}
					
					modifier.addEventListener(AsyncSWFModifierEvent.COMPLETE, function(ev:AsyncSWFModifierEvent):void
					{
						var diff:uint = getTimer() - start;
						log('Modifying swf took: '+diff+'ms');
						
						if(!instance)
						{
							preview.setSWFBackground(modifier.backgroundColor);
						}
						
						write(swf, context, instance, swfId);
					});
					
					modifier.start();
				}
				else
				{
					write(swf, context, instance);
				}
			}
			
			private function write(swf:SWF, context:LoaderContext = null, instance:Loader = null, swfId:int = -1):void
			{
				var start:uint = getTimer();
				
				var swfWriter:AsyncSWFWriter = new AsyncSWFWriter();
				
				if(!instance)
				{
					currentState = 'writing';
					swfWriter.addEventListener(AsyncSWFWriterEvent.TAG_WRITTEN, function(ev:AsyncSWFWriterEvent):void
					{
						writeProgress.setProgress(ev.progress, 1);
					});
				}
				
				swfWriter.addEventListener(AsyncSWFWriterEvent.WRITE_COMPLETE, function(ev:AsyncSWFWriterEvent):void
				{
					var diff:uint = getTimer() - start;
					
					log('Writing swf took: '+diff+'ms');
					
					var result:SWFWriteResult = ev.result;
					
					if(!instance)
					{
						debug.dump(result, 4);
						
						preview.setSWFSize((swf.header.frameSize.xMax - swf.header.frameSize.xMin)/20, (swf.header.frameSize.yMax - swf.header.frameSize.yMin)/20);
						
						swfId = 0;
					}
					try
					{
						save(result.bytes, lastUrl+'.recompiled.'+swfId+'.swf');
					}
					catch(e:*)
					{
						log('Could not write cached file');
					}
					
					run(result.bytes, context, instance);
				});

				swfWriter.write(swf);
			}
				
			private function run(bytes:ByteArray, context:LoaderContext = null, instance:Loader = null):void
			{
				if(instance)
				{
					log('[SWF] Rewrite complete... loading');
					instance['swfWire_loadBytes'](bytes, context);
				}
				else
				{
					lastInspectTarget = null;
					objectCollection.removeAll();
					netCollection.removeAll();
					
					currentState = 'loaded';
	
					lastRunBytes = bytes;
					var context:LoaderContext = new LoaderContext();
					context.allowCodeImport = true;
					context.applicationDomain = new ApplicationDomain(injectedAppDomain);

					var parameters:Object = {};
					var flashvarParser:URLVariables;
					if(flashvars.text)
					{
						try
						{
							flashvarParser = new URLVariables(flashvars.text);
							for(var iter:String in flashvarParser)
							{
								parameters[iter] = flashvarParser[iter];
							}
						}
						catch(e:Error)
						{
							log('Error parsing flashvars');
						}
					}
					
					context.parameters = parameters;
					
					preview.loadBytes(bytes, context);
				}
			}
			
			private function save(bytes:ByteArray, location:String):void
			{
				try
				{
					var f:File = new File(File.applicationDirectory.nativePath).resolvePath(location);
					var fs:FileStream = new FileStream();
					log('Writing to: '+f.nativePath);
					fs.open(f, FileMode.WRITE);
					fs.writeBytes(bytes);
					fs.close();
				}
				catch(e:*)
				{
					log('Error writing file to: '+location);
				}
			}
			
			private function log(message:String):void
			{
				trace(message);
				console.text += message+'\n';
				systemLog.text += message+'\n';
			}
			
			private function logToNet(instance:URLLoader, url:String, state:String):void
			{
				trace(url+': '+state);
				
				var data:Object = netObjects[instance];
				if(!data)
				{
					data = {};
					netObjects[instance] = data;
					netCollection.addItem(data);
				}
				
				data.url = url;
				data.state = state;
				data.current = instance.bytesLoaded;
				data.total = instance.bytesTotal;
				
				netCollection.itemUpdated(data);
			}
			
			private function updateStatus(message:String):void
			{
				statusLabel.htmlText = message;
			}
			
			protected function startInspection():void
			{
				inspectButton.selected = true;
				preview.loader.mouseEnabled = false;
				preview.loader.mouseChildren = false;
				preview.stage.addEventListener(MouseEvent.MOUSE_MOVE, inspect_mouseMoveHandler);
				preview.stage.addEventListener(MouseEvent.MOUSE_UP, inspect_mouseUpHandler);
				preview.highlight(null);
			}
			
			protected function stopInspection():void
			{
				inspectButton.selected = false;
				preview.stage.removeEventListener(MouseEvent.MOUSE_UP, inspect_mouseUpHandler);
				preview.stage.removeEventListener(MouseEvent.MOUSE_MOVE, inspect_mouseMoveHandler);
				preview.loader.mouseChildren = true;
				preview.loader.mouseEnabled = true;
				preview.highlight(null);
			}
			
			protected function runGC():void
			{
				inspect(preview.loader.content);
				System.gc();
				stage.addEventListener(Event.ENTER_FRAME, refreshObjectEnterFrameHandler);
			}
			
			protected function refreshObjectList():void
			{
				var existed:Object = {};
				var objects:Array = [];
				
				for(var iter:* in objectCollection)
				{
					var obj:* = objectCollection[iter];
					existed[obj.id] = obj;
					if(obj.delta != '-')
					{
						obj.delta = '-';
						objects.push(obj);
					}
				}
				
				var newObjects:Array = logger.enumerateObjects();
				
				for(var iter2:int = 0; iter2 < newObjects.length; iter2++)
				{
					var obj2:* = newObjects[iter2];
					var existing:* = existed[obj2.id];
					if(existing)
					{
						existing.delta = '';
					}
					else
					{
						obj2.delta = '+';
						objects.push(obj2);
					}
				}
				
				objects.sortOn('id', Array.NUMERIC);
				
				objectCollection.source = objects;
			}
			
			protected function updateStats():void
			{
				stats.addPoint(logger.getObjectCount(), System.privateMemory, currentFrameRate);
			}

			protected function showMethodEntry_clickHandler(event:MouseEvent):void
			{
				logger.showMethodEntry = showMethodEntry.selected;
			}

			protected function showMethodExit_clickHandler(event:MouseEvent):void
			{
				logger.showMethodExit = showMethodExit.selected;
			}
			
			protected function skipEnterFrame_clickHandler(ev:MouseEvent):void
			{
				logger.skipEnterFrame = skipEnterFrame.selected;
			}

			protected function skipExitFrame_clickHandler(ev:MouseEvent):void
			{
				logger.skipExitFrame = skipExitFrame.selected;
			}

			protected function skipRender_clickHandler(ev:MouseEvent):void
			{
				logger.skipRender = skipRender.selected;
			}

			protected function skipFrameConstructed_clickHandler(ev:MouseEvent):void
			{
				logger.skipFrameConstructed = skipFrameConstructed.selected;
			}

			protected function skipTimer_clickHandler(ev:MouseEvent):void
			{
				logger.skipTimer = skipTimer.selected;
			}

			protected function dumpArguments_clickHandler(event:MouseEvent):void
			{
				logger.showArguments = dumpArguments.selected;
			}

			protected function showTrace_clickHandler(event:MouseEvent):void
			{
				logger.showTraceStatements = showTrace.selected;
			}

			protected function logToOutput_clickHandler(event:MouseEvent):void
			{
				logger.logToOutput = logToOutput.selected;
			}

			protected function showReturn_clickHandler(event:MouseEvent):void
			{
				logger.showReturn = showReturn.selected;
			}

			protected function showObjectCreation_clickHandler(event:MouseEvent):void
			{
				logger.showObjectCreation = showObjectCreation.selected;
			}

			protected function clearConsole_clickHandler(event:MouseEvent):void
			{
				console.text = '';
			}

			protected function reload_clickHandler(event:MouseEvent):void
			{
				run(lastRunBytes);
			}
			
			protected function inspect_mouseUpHandler(ev:MouseEvent):void
			{
				stopInspection();
			}

			protected function logToTrace_clickHandler(event:MouseEvent):void
			{
				logger.logToTrace = logToTrace.selected;
			}

			protected function objectList_itemDoubleClickHandler(event:ListEvent):void
			{
				var info:Object = objectCollection.getItemAt(event.rowIndex);
				try
				{
					inspect(logger.getObjectById(info.id));
				}
				catch(e:*)
				{
					updateStatus('Error inspecting object.');
				}
			}

			protected function maxStackDepth_changeHandler(event:NumericStepperEvent):void
			{
				logger.maxStack = maxStackDepth.value;
			}

			protected function load_clickHandler(event:MouseEvent):void
			{
				load(swfUrl.text);
			}

			protected function refreshObjectEnterFrameHandler(ev:Event):void
			{
				stage.removeEventListener(Event.ENTER_FRAME, refreshObjectEnterFrameHandler);
				refreshObjectList();
			}
			
			protected function updateStatsTimerHandler(event:TimerEvent):void
			{
				updateStats();
			}
			
			protected function stats_creationCompleteHandler(event:FlexEvent):void
			{
				updateStatsTimer = new Timer(500);
				updateStatsTimer.addEventListener(TimerEvent.TIMER, updateStatsTimerHandler);
				updateStatsTimer.start();
			}			
			
			protected function consoleSearch_keyUpHandler(ev:Event):void
			{
				var search:String = consoleSearch.text.substr(console.selectionEndIndex);
				var re:RegExp = new RegExp(search, 'i');
				
				var index:int = console.text.search(re);
				if(index >= 0)
				{
					console.setSelection(index, index + search.length);
				}
			}
			
			protected function enterFrameHandler(ev:Event):void
			{
				if(logger)
				{
					logger.flushBuffer();
				}
				frameCount++;
				var now:int = getTimer();
				var diff:int = now - lastFrameRateUpdate;
				if(diff > 1000)
				{
					currentFrameRate = frameCount/(diff/1000);
					lastFrameRateUpdate = now;
					frameCount = 0;
				}
			}
			
			protected function snapshot_clickHandler(ev:MouseEvent):void
			{
				var bitmapData:BitmapData = new BitmapData(preview.width, preview.height);
				bitmapData.draw(preview.stage);
				var encoder:PNGEncoder = new PNGEncoder();
				var bytes:ByteArray = encoder.encode(bitmapData);
				var url:String = File.documentsDirectory.resolvePath('snapshot.'+(new Date().getTime())+'.png').url;
				save(bytes, url);
				updateStatus('Saved snapshot.  <a href="'+url+'">'+url+'</a>');
			}
			
			protected function objectListSearch_changeHandler(ev:Event):void
			{
				objectCollection.refresh();
			}
		]]>
	</mx:Script>
	<mx:states>
		<mx:State name="waiting">
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{loadProgress}"/>
			<mx:RemoveChild target="{readProgress}"/>
			<mx:RemoveChild target="{modifyProgress}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{systemLog}"/>
			<mx:RemoveChild target="{stats}"/>
		</mx:State>
		<mx:State name="loading">
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{readProgress}"/>
			<mx:RemoveChild target="{modifyProgress}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{swfDropTarget}"/>
			<mx:RemoveChild target="{stats}"/>
		</mx:State>
		<mx:State name="reading">
			<mx:RemoveChild target="{swfDropTarget}"/>
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{loadProgress}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{modifyProgress}"/>
			<mx:RemoveChild target="{stats}"/>
		</mx:State>
		<mx:State name="modifying">
			<mx:RemoveChild target="{swfDropTarget}"/>
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{loadProgress}"/>
			<mx:RemoveChild target="{readProgress}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{stats}"/>
		</mx:State>
		<mx:State name="writing">
			<mx:RemoveChild target="{swfDropTarget}"/>
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{loadProgress}"/>
			<mx:RemoveChild target="{readProgress}"/>
			<mx:RemoveChild target="{modifyProgress}"/>
			<mx:RemoveChild target="{stats}"/>
		</mx:State>
		<mx:State name="loaded">
			<mx:RemoveChild target="{loadProgress}"/>
			<mx:RemoveChild target="{readProgress}"/>
			<mx:RemoveChild target="{modifyProgress}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{swfDropTarget}"/>
			<mx:RemoveChild target="{systemLog}"/>
		</mx:State>
	</mx:states>
	<mx:HBox id="header" width="100%">
		<mx:Button styleName="logo"/>
		<ui:StatsGraph id="stats" width="100%" height="100%" creationComplete="stats_creationCompleteHandler(event)"/>
	</mx:HBox>
	<mx:Canvas width="100%" height="100%" id="swfDropTarget" backgroundColor="#000000" backgroundAlpha="0">
		<mx:VBox horizontalCenter="0" verticalCenter="0" horizontalAlign="center" id="vbox1" width="100%">
			<mx:Label text="Drop File Here" styleName="bigText"/>
			<mx:Form width="80%" id="form1">
				<mx:FormItem label="SWF URL: " width="100%">
					<mx:TextInput id="swfUrl" width="100%"/>
				</mx:FormItem>
				<mx:FormItem label="FlashVars: " width="100%">
					<mx:TextInput id="flashvars" width="100%"/>
				</mx:FormItem>
				<mx:FormItem label="Use Cached: ">
					<mx:CheckBox id="useCached"/>
				</mx:FormItem>
				<mx:FormItem label="Debug Loaded SWF files: ">
					<mx:CheckBox id="modifyChildren"/>
				</mx:FormItem>
			</mx:Form>
			<mx:Button label="Debug" click="load_clickHandler(event)" styleName="bigText"/>
		</mx:VBox>
	</mx:Canvas>
	<mx:TextArea id="systemLog" editable="false" width="100%" height="100%"/>
	<mx:HDividedBox width="100%" height="100%" id="hdividedbox1">
		<mx:VDividedBox width="100%" height="100%">
			<mx:HDividedBox width="100%" height="100%">
				<mx:VBox width="400" height="100%" verticalGap="0">
					<ui:BreadCrumb id="breadCrumb" width="100%" minWidth="0"/>
					<mx:Label id="inspectType" width="100%"/>
					<mx:TabNavigator id="inspectTabs" width="100%" height="100%" creationPolicy="all" backgroundAlpha="1" backgroundColor="#2C2C2C"
									 paddingBottom="5" paddingLeft="5" paddingTop="5" paddingRight="5" chromeColor="#131313" minHeight="0">
						<mx:Canvas width="100%" height="100%" label="Properties">
							<mx:DataGrid id="publicPropertiesGrid" width="100%" height="100%" horizontalScrollPolicy="auto" variableRowHeight="true">
								<mx:columns>
									<ui:AccessorTypeColumn headerText="" dataField="type" width="25" resizable="false"/>
									<mx:DataGridColumn headerText="Name" dataField="name" width="180"
													   itemRenderer="com.swfwire.debugger.ui.PropertyNameRenderer"/>
									<mx:DataGridColumn headerText="Value" dataField="value"
													   itemRenderer="com.swfwire.debugger.ui.PropertyValueRenderer"/>
								</mx:columns>
							</mx:DataGrid>
						</mx:Canvas>
						<mx:Canvas width="100%" height="100%" label="Methods">
							<mx:DataGrid id="publicMethodsGrid" width="100%" height="100%" horizontalScrollPolicy="auto" variableRowHeight="true">
								<mx:columns>
									<ui:AccessorTypeColumn headerText="" dataField="type" width="25" resizable="false"/>
									<mx:DataGridColumn headerText="Name" dataField="name"/>
								</mx:columns>
							</mx:DataGrid>
						</mx:Canvas>
						<mx:Canvas id="stylesCanvas" width="100%" height="100%" label="Styles">
							<mx:DataGrid id="stylesGrid" width="100%" height="100%" horizontalScrollPolicy="auto" variableRowHeight="true">
								<mx:columns>
									<mx:DataGridColumn headerText="Name" dataField="name" width="200"/>
									<mx:DataGridColumn headerText="Value" dataField="value"
													   itemRenderer="com.swfwire.debugger.ui.PropertyValueRenderer"/>
								</mx:columns>
							</mx:DataGrid>
						</mx:Canvas>
					</mx:TabNavigator>
				</mx:VBox>
			</mx:HDividedBox>
			<mx:VBox width="100%" height="100%">
				<mx:HBox height="40" width="100%">
					<mx:Button id="inspectButton" label="Inspect" click="inspectButton.selected ? stopInspection() : startInspection()" height="100%"/>
					<mx:Button label="Reset Position" click="preview.resetSWFPosition()" height="100%"/>
					<mx:Button label="Snapshot" click="snapshot_clickHandler(event)" height="100%"/>
					<mx:Spacer width="100%"/>
					<mx:Button label="Reload" click="reload_clickHandler(event)" height="100%"/>
				</mx:HBox>
				<mx:TabNavigator id="tabnavigator1" width="100%" height="100%" creationPolicy="all" backgroundAlpha="1" backgroundColor="#2C2C2C"
								 paddingBottom="5" paddingLeft="5" paddingTop="5" paddingRight="5" chromeColor="#131313" minHeight="0">
					<mx:HBox label="Console" width="100%" height="100%" horizontalGap="5">
						<mx:VBox width="100%" height="100%">
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:TextInput id="consoleSearch" width="250" change="consoleSearch_keyUpHandler(event)"/>
								<mx:Spacer width="100%"/>
								<mx:Button label="Clear Console" click="clearConsole_clickHandler(event)"/>
							</mx:HBox>
							<ui:HighlightedTextArea id="console" width="100%" height="100%" editable="false" fontFamily="Courier New" fontSize="11"/>
						</mx:VBox>
						<mx:VBox height="100%" id="vbox2" paddingRight="5" minHeight="0" horizontalScrollPolicy="off" width="200">
							<mx:CheckBox id="logToOutput"			 label="Log to console"			 click="logToOutput_clickHandler(event)"/>
							<mx:CheckBox id="logToTrace"			 label="Log to trace"			 click="logToTrace_clickHandler(event)" styleName="smallText"/>
							<mx:CheckBox id="showTrace"				 label="Show trace"				 click="showTrace_clickHandler(event)" styleName="smallText"/>
							<mx:CheckBox id="showMethodEntry"		 label="Show method entry"		 click="showMethodEntry_clickHandler(event)" styleName="smallText"/>
							<mx:CheckBox id="dumpArguments"			 label="Show arguments"			 click="dumpArguments_clickHandler(event)" styleName="smallText"/>
							<mx:CheckBox id="showReturn"			 label="Show return values"		 click="showReturn_clickHandler(event)" styleName="smallText"/>
							<mx:CheckBox id="showObjectCreation"	 label="Show object creation"	 click="showObjectCreation_clickHandler(event)" styleName="smallText"/>
							<mx:CheckBox id="showMethodExit"		 label="Show method exit"		 click="showMethodExit_clickHandler(event)" styleName="smallText"/>
							<mx:CheckBox id="skipEnterFrame"		 label="Skip ENTER_FRAME"		 click="skipEnterFrame_clickHandler(event)" styleName="smallText"/>
							<mx:CheckBox id="skipExitFrame"			 label="Skip EXIT_FRAME"		 click="skipExitFrame_clickHandler(event)" styleName="smallText"/>
							<mx:CheckBox id="skipRender"			 label="Skip RENDER"			 click="skipRender_clickHandler(event)" styleName="smallText"/>
							<mx:CheckBox id="skipFrameConstructed"	 label="Skip FRAME_CONSTRUCTED"	 click="skipFrameConstructed_clickHandler(event)" styleName="smallText"/>
							<mx:CheckBox id="skipTimer"				 label="Skip TIMER"				 click="skipTimer_clickHandler(event)" styleName="smallText"/>
							<mx:HBox id="hbox1" height="50" verticalAlign="middle">
								<mx:Label text="Max Stack Depth:" styleName="smallText" paddingTop="2"/>
								<mx:NumericStepper id="maxStackDepth" value="10" change="maxStackDepth_changeHandler(event)" minimum="0" maximum="100"/>
							</mx:HBox>
						</mx:VBox>
					</mx:HBox>
					<mx:Canvas label="Display List">
						<mx:TextArea id="tempDisplayList" width="100%" height="100%" editable="false"/>
					</mx:Canvas>
					<mx:Canvas label="Net">
						<mx:DataGrid id="netList" width="100%" height="100%" horizontalScrollPolicy="auto">
							<mx:columns>
								<mx:DataGridColumn headerText="URL" dataField="url" width="500"/>
								<mx:DataGridColumn headerText="Progress" dataField="progress" 
												   itemRenderer="com.swfwire.debugger.ui.NetProgressRenderer"/>
							</mx:columns>
						</mx:DataGrid>
					</mx:Canvas>
					<mx:VBox label="Objects" width="100%">
						<mx:HBox width="100%">
							<mx:TextInput id="objectListSearch" width="250" change="objectListSearch_changeHandler(event)"/>
							<mx:Spacer width="100%"/>
							<mx:Button label="Refresh" click="refreshObjectList()"/>
							<mx:Button label="Run Garbage Collector" click="runGC()"/>
						</mx:HBox>
						<ui:ObjectListDataGrid id="objectList" width="100%" height="100%"
											   itemDoubleClick="objectList_itemDoubleClickHandler(event)"/>
					</mx:VBox>
				</mx:TabNavigator>
				<mx:Label id="statusLabel" width="100%" selectable="true"/>
			</mx:VBox>
		</mx:VDividedBox>
	</mx:HDividedBox>
	<mx:ProgressBar id="loadProgress" width="100%" mode="manual" label="Loading SWF: %3%%" styleName="bigText"/>
	<mx:ProgressBar id="readProgress" width="100%" mode="manual" label="Reading SWF: %3%%" styleName="bigText"/>
	<mx:ProgressBar id="modifyProgress" width="100%" mode="manual" label="Modifying SWF: %3%%" styleName="bigText"/>
	<mx:ProgressBar id="writeProgress" width="100%" mode="manual" label="Writing SWF: %3%%" styleName="bigText"/>
</mx:WindowedApplication>
