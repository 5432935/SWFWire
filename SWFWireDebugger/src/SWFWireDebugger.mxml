<?xml version="1.0" encoding="utf-8"?>
<mx:WindowedApplication xmlns:mx="http://www.adobe.com/2006/mxml" 
						xmlns:ui="com.swfwire.debugger.flex.ui.*"
						showStatusBar="false"
						applicationComplete="main()"
						minWidth="400" minHeight="300"
						paddingLeft="5" paddingTop="5"
						horizontalAlign="right"
						currentState="waiting" backgroundColor="#222222">
	<mx:Style source="style.css"/>
	<mx:Script>
		<![CDATA[
			import air.update.ApplicationUpdaterUI;
			
			import com.swfwire.debugger.utils.*;
			import com.swfwire.decompiler.*;
			import com.swfwire.decompiler.abc.ABCInstructions;
			import com.swfwire.decompiler.abc.ABCReaderMetadata;
			import com.swfwire.decompiler.abc.instructions.*;
			import com.swfwire.decompiler.abc.tokens.*;
			import com.swfwire.decompiler.abc.tokens.multinames.MultinameQNameToken;
			import com.swfwire.decompiler.abc.tokens.traits.TraitMethodToken;
			import com.swfwire.decompiler.data.swf.SWF;
			import com.swfwire.decompiler.data.swf.SWFHeader;
			import com.swfwire.decompiler.data.swf.tags.SetBackgroundColorTag;
			import com.swfwire.decompiler.data.swf9.tags.DoABCTag;
			import com.swfwire.decompiler.data.swf9.tags.SymbolClassTag;
			import com.swfwire.decompiler.events.AsyncSWFReaderEvent;
			import com.swfwire.decompiler.events.AsyncSWFWriterEvent;
			import com.swfwire.utils.Debug;
			import com.swfwire.utils.DisplayUtil;
			import com.swfwire.utils.ObjectUtil;
			import com.swfwire.utils.air.WindowTracker;
			
			import flash.utils.describeType;
			import flash.utils.getTimer;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.controls.TextInput;
			import mx.core.IUIComponent;
			import mx.core.UIComponent;
			import mx.events.DataGridEvent;
			import mx.events.DataGridEventReason;
			import mx.events.DynamicEvent;
			import mx.managers.DragManager;
			
			private var windowTracker:WindowTracker;
			private var appUpdater:ApplicationUpdaterUI;
			private var urlLoader:URLLoader;
			
			private var logger:*;
			private var injectedAppDomain:ApplicationDomain;
			private var lastUrl:String;
			private var isCached:Boolean;
			private var foundMainClass:Boolean;
			
			private var sanityCheck:Boolean = false;
			private var cacheEnabled:Boolean = false;
			
			private function main():void
			{
				logOut.text = 'Version '+Config.VERSION+'\n';
				
				stage.addEventListener(Event.ENTER_FRAME, function(ev:*):void
				{
					if(logger)
					{
						logger.enterFrame();
					}
				});
				
				appUpdater = new ApplicationUpdaterUI();
				appUpdater.configurationFile = new File('app:/updateConfig.xml');
				appUpdater.initialize();
				
				windowTracker = new WindowTracker(SharedObject.getLocal('preferences'), nativeWindow);
				windowTracker.restore();
				windowTracker.startTracking();
				
				urlLoader = new URLLoader();
				urlLoader.addEventListener(ProgressEvent.PROGRESS,	 loadProgressHandler);
				urlLoader.addEventListener(Event.COMPLETE,			 loadCompleteHandler);
				urlLoader.dataFormat = URLLoaderDataFormat.BINARY;
				
				header.addEventListener(NativeDragEvent.NATIVE_DRAG_ENTER,	 dragEnterHandler);
				header.addEventListener(NativeDragEvent.NATIVE_DRAG_DROP,	 dragDropHandler);
				
				preview.addEventListener(MouseEvent.MIDDLE_MOUSE_DOWN, previewMiddleDownHandler);
				preview.addEventListener(MouseEvent.MOUSE_WHEEL, previewMiddleScrollHandler);
				
				loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, function(ev:UncaughtErrorEvent):void
				{
					ev.preventDefault();
					ev.stopPropagation();
					ev.stopImmediatePropagation();
					logger.uncaughtError(ev.error);
				});
				
				//preview.addEventListener(MouseEvent.CONTEXT_MENU, inspectHandler);
				//preview.addEventListener(MouseEvent.MOUSE_MOVE, inspectHandler);
				preview.addEventListener('loaderComplete', function(ev:Event):void
				{
					preview.loader.contentLoaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, function(ev:UncaughtErrorEvent):void
					{
						ev.preventDefault();
						ev.stopPropagation();
						ev.stopImmediatePropagation();
						logger.uncaughtError(ev.error);
					});
					
					if(!sanityCheck)
					{
						var a:* = preview.loader.content;
						if(foundMainClass)
						{
							a.deferredConstructor();
						}
						preview.invalidateDisplayList();
						preview.validateDisplayList();
					}
				});
				
				Debug.enabled = true;
				
				var context:LoaderContext = new LoaderContext();
				context.applicationDomain = new ApplicationDomain();
				context.allowCodeImport = true;
				
				injectionLoader = new Loader();
				injectionLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(ev:*):void
				{
					injectedAppDomain = injectionLoader.contentLoaderInfo.applicationDomain;
					
					logOut.text += 'Injection loaded\n';
					
					logger = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.Logger');
					logger.output = logOut;
					logToTrace.selected = logger.logToTrace;
					logToOutput.selected = logger.logToOutput;
					logToTrace.selected = logger.logToTrace;
					showMethodEntry.selected = logger.showMethodEntry;
					showMethodExit.selected = logger.showMethodExit;
					showTrace.selected = logger.showTraceStatements;
					dumpArguments.selected = logger.showArguments;
					showReturn.selected = logger.showReturn;
					
					//injectedAppDomain.getDefinition('com.swfwire.debugger.injected').output = logOut;
					loadDefault();
				});
				
				var librarySwf:String = 'app:/library.swf';
				//var librarySwf:String = new File(File.applicationDirectory.nativePath).resolvePath('library.swf?nocache='+Math.random()).url;
				
				inspectGrid.dataProvider = inspectGridDP;
				
				breadCrumb.addEventListener('breadCrumbClick', function(ev:DynamicEvent):void
				{
					inspect(pathRefs[ev.index]);
				});
				
				injectionLoader.load(new URLRequest(librarySwf), context);
				//loadDefault();
			}
			
			private var previewStartDown:Point;
			
			private function previewMiddleDownHandler(ev:MouseEvent):void
			{
				stopInspection();
				preview.loader.mouseEnabled = false;
				preview.loader.mouseChildren = false;
				stage.addEventListener(MouseEvent.MIDDLE_MOUSE_UP, previewMiddleUpHandler);
				stage.addEventListener(MouseEvent.MOUSE_MOVE, previewMoveHandler);
				previewStartDown = new Point(stage.mouseX - preview.loader.x, stage.mouseY - preview.loader.y);
			}
			
			private function previewMoveHandler(ev:MouseEvent):void
			{
				if(previewStartDown)
				{
					preview.loader.x = stage.mouseX - previewStartDown.x; 
					preview.loader.y = stage.mouseY - previewStartDown.y; 
				}
			}
			
			private function previewMiddleUpHandler(ev:MouseEvent):void
			{
				stage.removeEventListener(MouseEvent.MOUSE_MOVE, previewMoveHandler);
				stage.removeEventListener(MouseEvent.MIDDLE_MOUSE_UP, previewMiddleUpHandler);
				preview.loader.mouseChildren = true;
				preview.loader.mouseEnabled = true;
			}
			
			private function previewMiddleScrollHandler(ev:MouseEvent):void
			{
				var scaleFactor:Number = Math.pow(1.05, ev.delta);
				
				var mouseNow:Point = new Point(preview.loader.mouseX, preview.loader.mouseY);
				var previousMousePosition:Point = preview.loader.localToGlobal(mouseNow);
				
				preview.loader.scaleX *= scaleFactor;
				preview.loader.scaleY *= scaleFactor;
				
				var newMousePosition:Point = preview.loader.localToGlobal(mouseNow);
				
				preview.loader.x -= newMousePosition.x - previousMousePosition.x;
				preview.loader.y -= newMousePosition.y - previousMousePosition.y;
			}
			
			private function swfwireRel(url:String):String
			{
				return new File(File.applicationDirectory.nativePath).parent.parent.resolvePath(url).url;				
			}
			
			private var injectionLoader:Loader;
			
			private function loadDefault():void
			{
				
				//load(new File(File.applicationDirectory.nativePath).parent.parent.resolvePath('SWFCorpseFlex4-1/bin-debug/Main.swf').url);
				//load(new File(File.applicationDirectory.nativePath).parent.parent.resolvePath('SWFCorpse/bin-debug/SWFCorpse.swf').url);
				//load(new File(File.applicationDirectory.nativePath).parent.parent.resolvePath('SWFCorpse/bin-release/SWFCorpse.swf').url);
				//load(new File(File.applicationDirectory.nativePath).parent.parent.resolvePath('SWFWireInspector/bin-debug/SWFWireInspector.swf').url);
				//load(new File(File.applicationDirectory.nativePath).parent.parent.resolvePath('SWFCorpseFlex3-5/bin-debug/Main.swf').url);
				//load('temp.swf');
				//load('SlowMoPlayer.swf');
				//load('cs5-5_pfflib.swf');
				//load('frees.swf');
				//load('cs5-5_corpse.swf');
				load('watch_as3.swf');
			}
			
			private var lastTarget:DisplayObject;
			private var inspectGridDP:ArrayCollection = new ArrayCollection();
			private var pathRefs:Array;
			
			private function inspectHandler(ev:MouseEvent):void
			{
				var previewOverlay:UIComponent = preview.overlay;
				
				var point:Point = new Point(stage.mouseX, stage.mouseY);
				var hits:Array = stage.getObjectsUnderPoint(point);
				
				var target:DisplayObject = hits.pop();
				if(target == previewOverlay)
				{
					target = hits.pop();
				}
				if(!preview.loader.contains(target))
				{
					target = null;
				}

				if(target != lastTarget)
				{
					lastTarget = target;
					
					var overlayGraphics:Graphics = previewOverlay.graphics;
					overlayGraphics.clear();
					var path:Array = [];
					pathRefs = [];
					if(target)
					{
						var rect:Rectangle = target.getRect(previewOverlay);
						overlayGraphics.lineStyle(4, 0x00FF00, 0.5);
						overlayGraphics.drawRect(rect.x, rect.y, rect.width, rect.height);
						
						while(target && target.parent)
						{
							if(target == preview.loader)
							{
								break;
							}
							path.push(target.name);
							pathRefs.push(target);
							target = target.parent;
						}
						path.reverse();
						pathRefs.reverse();
						//path = DisplayUtil.getDisplayObjectPath(target, preview.loader.content);
						inspect(lastTarget);
					}
					breadCrumb.history = path;
					//inspectOut.text += ObjectUtil.objectToString(lowT, 2, 3, 50, 50, '  ');
				}
			}
			
			protected function inspect(target:DisplayObject):void
			{
				inspectGridDP.removeAll();
				
				var description:XML = describeType(target);
				var node:XML;
				var name:String;
				var props:Array = [];
				
				for each(node in description.variable)
				{
					props.push(node.@name);
					inspectGridDP.addItem({name: node.@name, value: target[node.@name]});
				}
				
				inspectType.text = description.@name;
				
				for each(name in description.accessor.(@access == 'readwrite' || @access == 'readonly').@name)
				{
					props.push(name);
				}
				
				for(name in target)
				{
					props.push(name);
				}
				
				props.sort();
				
				for(var iter:uint = 0; iter < props.length; iter++)
				{
					try
					{
						inspectGridDP.addItem({name: props[iter], value: target[props[iter]]});
					}
					catch(e:Error)
					{
						inspectGridDP.addItem({name: props[iter], value: '<exception thrown by getter>'});
					}
				}
			}
			
			protected function inspectGrid_itemEditEndHandler(event:DataGridEvent):void
			{
				if(event.reason != DataGridEventReason.CANCELLED)
				{
					if(lastTarget)
					{
						var info:Object = inspectGridDP.getItemAt(event.rowIndex);
						try
						{
							lastTarget[info.name] = TextInput(event.currentTarget.itemEditorInstance).text;
						}
						catch(e:*)
						{
							logOut.text += 'Error setting property.\n';
						}
					}
				}
			}
			
			private function loadProgressHandler(ev:ProgressEvent):void
			{
				loadProgress.setProgress(ev.bytesLoaded, ev.bytesTotal);
			}
			
			private function loadCompleteHandler(ev:Event):void
			{
				var bytes:ByteArray = urlLoader.data as ByteArray;
				if(bytes)
				{
					if(isCached || sanityCheck)
					{
						readProgress.setProgress(1, 1);
						writeProgress.setProgress(1, 1);
						run(bytes);
						/*
						var context:LoaderContext = new LoaderContext();
						context.allowLoadBytesCodeExecution = true;
						//context.applicationDomain = new ApplicationDomain();
						context.applicationDomain = new ApplicationDomain(injectedAppDomain);
						preview.loadBytes(bytes, context);
						preview.loader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(ev:*):void
						{
							var temp:* = preview.loader.contentLoaderInfo.applicationDomain.hasDefinition('com.swfwire.debugger.injected.Logger');
							Debug.dump({temp: temp});
						});
						*/
					}
					else
					{
						parse(bytes);
					}
				}
			}
			
			private function dragEnterHandler(ev:NativeDragEvent):void
			{
				DragManager.acceptDragDrop(IUIComponent(ev.currentTarget));
			}
			
			private function dragDropHandler(ev:NativeDragEvent):void
			{
				var clipboard:Clipboard = ev.clipboard;
				var url:String = '';
				if(clipboard.hasFormat(ClipboardFormats.URL_FORMAT))
				{
					url = clipboard.getData(ClipboardFormats.URL_FORMAT) as String;
				}
				else if(clipboard.hasFormat(ClipboardFormats.TEXT_FORMAT))
				{
					url = clipboard.getData(ClipboardFormats.TEXT_FORMAT) as String;
				}
				else if(clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
				{
					var files:Array = clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array;
					var file:File = files[0];
					if(file)
					{
						url = file.url;
					}
				}
				if(url)
				{
					currentState = 'loading';
					load(url);
				}
				else
				{
					Alert.show('Could not parse any valid SWF file from the drop.', 'No data');
				}
			}
			
			private function parse(bytes:ByteArray):void
			{
				currentState = 'reading';

				var swfBytes:SWFByteArray = new SWFByteArray(bytes);
				var swfReader:AsyncSWFReaderFiltered = new AsyncSWFReaderFiltered();
				var result:SWFReadResult;
				
				swfReader.includedTags[0] = true;
				swfReader.includedTags[9] = true;
				swfReader.includedTags[76] = true;
				swfReader.includedTags[82] = true;
				swfReader.addEventListener(AsyncSWFReaderEvent.TAG_READ, function(ev:Event):void
				{
					var current:uint = swfBytes.getBytePosition();
					var max:uint = swfBytes.getLength();
					readProgress.setProgress(current, max);
				});
				swfReader.addEventListener(AsyncSWFReaderEvent.READ_COMPLETE, function(ev:Event):void
				{
					inject(result.swf, result.abcMetadata);
				});
				
				result = swfReader.read(swfBytes);
			}
			
			private function inject(swf:SWF, metadata:Vector.<ABCReaderMetadata>):void
			{
				var start:uint = getTimer();
				
				swf.header.signature = SWFHeader.UNCOMPRESSED_SIGNATURE;
				
				var mainClass:String = '';
				var iTag:uint;
				
				var backgroundColor:uint = 0xFFFFFF;
				
				for(iTag = 0; iTag < swf.tags.length; iTag++)
				{
					var bgt:SetBackgroundColorTag = swf.tags[iTag] as SetBackgroundColorTag;
					if(bgt)
					{
						backgroundColor = bgt.backgroundColor.red << 16 | bgt.backgroundColor.green << 8 | bgt.backgroundColor.blue;
					}
					var sct:SymbolClassTag = swf.tags[iTag] as SymbolClassTag;
					if(sct)
					{
						for(var isym:uint = 0; isym < sct.symbols.length; isym++)
						{
							if(sct.symbols[isym].characterId == 0)
							{
								mainClass = sct.symbols[isym].className;
							}
						}
					}
				}
				
				trace('main class: '+mainClass);
				
				foundMainClass = false;
				if(mainClass != '')
				{
					foundMainClass = true;
				}
				
				var mainClassPackage:String = '';
				var mainClassName:String = mainClass;
				
				if(mainClass.indexOf('.') >= 0)
				{
					mainClassName = mainClass.substr(mainClass.lastIndexOf('.') + 1);
					mainClassPackage = mainClass.substr(0, mainClass.lastIndexOf('.'));
				}
				for(iTag = 0; iTag < swf.tags.length; iTag++)
				{
					var abcTag:DoABCTag = swf.tags[iTag] as DoABCTag;
					if(abcTag)
					{
						var wrapper:ABCWrapper = new ABCWrapper(abcTag.abcFile, metadata[iTag]);
						
						var injectedNamespace:uint = wrapper.addNamespaceFromString('com.swfwire.debugger.injected');
						
						var securityIndex:int = wrapper.getMultinameIndex('flash.system', 'Security');
						if(securityIndex >= 0)
						{
							var securityQName:MultinameQNameToken = abcTag.abcFile.cpool.multinames[securityIndex].data as MultinameQNameToken;
							securityQName.ns = injectedNamespace;
						}
						var externalInterfaceIndex:int = wrapper.getMultinameIndex('flash.external', 'ExternalInterface');
						if(externalInterfaceIndex >= 0)
						{
							var externalInterfaceQName:MultinameQNameToken = abcTag.abcFile.cpool.multinames[externalInterfaceIndex].data as MultinameQNameToken;
							externalInterfaceQName.ns = injectedNamespace;
						}
						
						var mainIndex:int = wrapper.getMultinameIndex(mainClassPackage, mainClassName);
						var mainInst:InstanceToken = null;
						
						if(mainIndex >= 0)
						{
							for(var i:uint = 0; i < abcTag.abcFile.instances.length; i++)
							{
								var inst:InstanceToken = abcTag.abcFile.instances[i];
								if(inst.name == mainIndex)
								{
									mainInst = inst;
									break;
								}
							}
						}

						if(mainInst)
						{
							var mainMB:MethodBodyInfoToken = wrapper.findMethodBody(mainInst.iinit);
							
							//Create method deferredConstructor on main class
							var defcmni:int = wrapper.addQName(
								wrapper.addNamespaceFromString(''), 
								wrapper.addString('deferredConstructor'));

							var mainTrait:TraitsInfoToken = new TraitsInfoToken(defcmni,
								TraitsInfoToken.KIND_TRAIT_METHOD,
								0,
								new TraitMethodToken(0, mainInst.iinit));
							
							mainInst.traits.push(mainTrait);
							
							//Update the readable name for the method
							/*
							var origcm:MethodInfoToken = abcTag.abcFile.methods[mainInst.iinit];
							origcm.name = wrapper.addString(mainClass+'/deferredConstructor');
							*/
							
							//Create the new constructor
							var defcmi:uint = abcTag.abcFile.methods.push(new MethodInfoToken()) - 1;
							
							var emptyMethod:MethodBodyInfoToken = new MethodBodyInfoToken(
								defcmi, 1, 1, mainMB.initScopeDepth, mainMB.initScopeDepth + 1);
							emptyMethod.instructions = wrapper.getEmptyConstructorInstructions();
							
							abcTag.abcFile.methodBodies.push(emptyMethod);
							
							//mainMB.method = defcmi;
							
							mainInst.iinit = defcmi;
							
							//mainInst.iinit = fci;
						}

						//Debug.log('test', 'after', mainInst.traits);
						
						//mainInst.iinit--;
						
						if(true)
						{
							var cp:ConstantPoolToken = abcTag.abcFile.cpool;
							var l:*;
							const minScopeDepth:uint = 3;
							
							var loggerClassIndex:int = wrapper.addQName(
								wrapper.addNamespaceFromString('com.swfwire.debugger.injected'), 
								wrapper.addString('Logger'));
							
							var emptyNS:int = wrapper.addNamespaceFromString('');
							
							var enterFunctionIndex:int = wrapper.addQName(emptyNS, wrapper.addString('enterFunction'));
							var exitFunctionIndex:int = wrapper.addQName(emptyNS, wrapper.addString('exitFunction'));
							
							var traceIndex:int = wrapper.getMultinameIndex('', 'trace');
							if(traceIndex >= 0)
							{
								l = wrapper.findInstruction(new InstructionTemplate(Instruction_findpropstrict, {index: traceIndex}));
								
								for(var iter:* in l)
								{
									abcTag.abcFile.methodBodies[l[iter].methodBody].maxStack += 1;
								}
								
								wrapper.replaceInstruction2(l, function(z:*, a:Vector.<IInstruction>):Vector.<IInstruction>
								{
									var b:Vector.<IInstruction> = new Vector.<IInstruction>();
									b.push(new Instruction_getlex(loggerClassIndex));
									wrapper.redirectReferences(z.methodBody, a[0], b[0]);
									return b;
								});
							
								var methodIndex:int = wrapper.addQName(emptyNS, wrapper.addString('log'));
								
								l = wrapper.findInstruction(new InstructionTemplate(Instruction_callpropvoid, {index: traceIndex}));
								wrapper.replaceInstruction2(l, function(z:*, a:Vector.<IInstruction>):Vector.<IInstruction>
								{
									var b:Vector.<IInstruction> = new Vector.<IInstruction>();
									b.push(new Instruction_callpropvoid(methodIndex, Object(a[0]).argCount));
									wrapper.redirectReferences(z.methodBody, a[0], b[0]);
									return b;
								});
								
								l = wrapper.findInstruction(new InstructionTemplate(Instruction_callproperty, {index: traceIndex}));
								wrapper.replaceInstruction2(l, function(z:*, a:Vector.<IInstruction>):Vector.<IInstruction>
								{
									var b:Vector.<IInstruction> = new Vector.<IInstruction>();
									b.push(new Instruction_callproperty(methodIndex, Object(a[0]).argCount));
									wrapper.redirectReferences(z.methodBody, a[0], b[0]);
									return b;
								});
							}

							var nameFromMethodId:Object = {};
							
							function qnameToString(index:uint):String
							{
								var result:String = '<Not a QName>';
								var mq:MultinameQNameToken = cp.multinames[index].data as MultinameQNameToken;
								if(mq)
								{
									var ns:String = cp.strings[cp.namespaces[mq.ns].name].utf8;
									if(ns != '')
									{
										ns = ns + '::';
									}
									result = ns + cp.strings[mq.name].utf8;
								}
								return result;
							}
							
							for(var i11:int = 0; i11 < abcTag.abcFile.instances.length; i11++)
							{
								var inst2:InstanceToken = abcTag.abcFile.instances[i11];
								
								var instName:String = qnameToString(inst2.name);
								
								nameFromMethodId[inst2.iinit] = instName;
								for(var i12:int = 0; i12 < inst2.traits.length; i12++)
								{
									var name:String = qnameToString(inst2.traits[i12].name);
									var tmt:TraitMethodToken = inst2.traits[i12].data as TraitMethodToken;
									switch(inst2.traits[i12].kind)
									{
										case TraitsInfoToken.KIND_TRAIT_GETTER:
											name = 'get '+name;
											break;
										case TraitsInfoToken.KIND_TRAIT_SETTER:
											name = 'set '+name;
											break;
									}
									if(tmt)
									{
										nameFromMethodId[tmt.methodId] = instName+'/'+name;
									}
								}
							}
							
							for(var i13:int = 0; i13 < abcTag.abcFile.classes.length; i13++)
							{
								var classInfo:ClassInfoToken = abcTag.abcFile.classes[i13];
								var inst3:InstanceToken = abcTag.abcFile.instances[i13];
								
								var className:String = qnameToString(inst3.name);
								
								nameFromMethodId[classInfo.cinit] = className+'$cinit';
								
								for(var i14:int = 0; i14 < classInfo.traits.length; i14++)
								{
									var name2:String = qnameToString(classInfo.traits[i14].name);
									var tmt2:TraitMethodToken = classInfo.traits[i14].data as TraitMethodToken;
									switch(classInfo.traits[i14].kind)
									{
										case TraitsInfoToken.KIND_TRAIT_GETTER:
											name = 'get '+name;
											break;
										case TraitsInfoToken.KIND_TRAIT_SETTER:
											name = 'set '+name;
											break;
									}
									if(tmt2)
									{
										nameFromMethodId[tmt2.methodId] = className+'$/'+name2;
									}
								}
							}
							
							l = wrapper.findInstruction(new InstructionTemplate(Instruction_newfunction, {}));
							for(var i15:int = 0; i15 < l.length; i15++)
							{
								var mb2:MethodBodyInfoToken = abcTag.abcFile.methodBodies[l[i15].methodBody];
								var newfinst:Instruction_newfunction = mb2.instructions[l[i15].id] as Instruction_newfunction;
								nameFromMethodId[newfinst.index] = nameFromMethodId[mb2.method]+'/<anonymous>';
							}

							//Debug.dump(nameFromMethodId, 20);

							for(var i9:int = 0; i9 < abcTag.abcFile.methodBodies.length; i9++)
							{
								var mb:MethodBodyInfoToken = abcTag.abcFile.methodBodies[i9];
								
								if(!nameFromMethodId[mb.method])
								{
									//trace('Couldn\'t find a method name for '+mb.method);
								}
								
								if(mb.initScopeDepth >= minScopeDepth)
								{
									var j9:* = abcTag.abcFile.methodBodies[i9].instructions;
									
									var paramCount:uint = abcTag.abcFile.methods[mb.method].paramCount;

									
									j9.unshift(new Instruction_callpropvoid(enterFunctionIndex, 3));
									
									if(paramCount > 0)
									{
										abcTag.abcFile.methodBodies[i9].maxStack += paramCount * 2 + 3;
										j9.unshift(new Instruction_newobject(paramCount));
	
										for(var i10:int = paramCount - 1; i10 >= 0; i10--)
										{
											var paramName:ParamInfoToken = abcTag.abcFile.methods[mb.method].paramNames[i10];
											j9.unshift(new Instruction_getlocal(i10 + 1));
											if(paramName && paramName.value > 0)
											{
												j9.unshift(new Instruction_pushstring(paramName.value));
											}
											else
											{
												j9.unshift(new Instruction_pushstring(wrapper.addString('param'+i10)));
											}
										}
									}
									else
									{
										abcTag.abcFile.methodBodies[i9].maxStack += 4;
										j9.unshift(new Instruction_pushnull());
									}
									
									j9.unshift(new Instruction_getlocal0());
									
									var methodId:int =  wrapper.addString(iTag+'.'+String(i9));
									var methodName:String = nameFromMethodId[mb.method];
									if(methodName)
									{
										methodId =  wrapper.addString(methodName);
									}
									j9.unshift(new Instruction_pushstring(methodId));
									j9.unshift(new Instruction_getlex(loggerClassIndex));
								}
							}
							
							
							l = wrapper.findInstruction(new InstructionTemplate(Instruction_returnvoid, {}));
							
							for(var iter6:* in l)
							{
								abcTag.abcFile.methodBodies[l[iter6].methodBody].maxStack += 1;
							}
							
							wrapper.replaceInstruction2(l, function(z:InstructionLocation, a:Vector.<IInstruction>):Vector.<IInstruction>
							{
								var mb:MethodBodyInfoToken = abcTag.abcFile.methodBodies[z.methodBody];
								if(mb.initScopeDepth >= minScopeDepth)
								{
									a.unshift(new Instruction_callpropvoid(exitFunctionIndex, 1));
									
									var methodId:int =  wrapper.addString(iTag+'.'+z.methodBody);
									var methodName:String = nameFromMethodId[mb.method];
									if(methodName)
									{
										methodId =  wrapper.addString(methodName);
									}
									a.unshift(new Instruction_pushstring(methodId));

									a.unshift(new Instruction_getlex(loggerClassIndex));
								}
								wrapper.redirectReferences(z.methodBody, a[a.length - 1], a[0]);
								return a;
							});
							
							l = wrapper.findInstruction(new InstructionTemplate(Instruction_returnvalue, {}));
							
							for(iter6 in l)
							{
								abcTag.abcFile.methodBodies[l[iter6].methodBody].maxStack += 1;
							}
							
							wrapper.replaceInstruction2(l, function(z:InstructionLocation, a:Vector.<IInstruction>):Vector.<IInstruction>
							{
								var mb:MethodBodyInfoToken = abcTag.abcFile.methodBodies[z.methodBody];
								if(mb.initScopeDepth >= minScopeDepth)
								{
									a.unshift(new Instruction_callpropvoid(exitFunctionIndex, 2));
									a.unshift(new Instruction_swap());
									
									var methodId:int =  wrapper.addString(iTag+'.'+z.methodBody);
									var methodName:String = nameFromMethodId[mb.method];
									if(methodName)
									{
										methodId =  wrapper.addString(methodName);
									}
									a.unshift(new Instruction_pushstring(methodId));

									a.unshift(new Instruction_swap());
									a.unshift(new Instruction_getlex(loggerClassIndex));
									a.unshift(new Instruction_dup());
								}
								wrapper.redirectReferences(z.methodBody, a[a.length - 1], a[0]);
								return a;
							});
						}
					}
				}
				
				var diff:uint = getTimer() - start;
				
				trace('Modifying swf took: '+diff+'ms');
				logOut.text += 'Modifying swf took: '+diff+'ms\n';
				
				start = getTimer();

				/*
				var swfWriter:SWF10Writer = new SWF10Writer();
				var result:SWFWriteResult = swfWriter.write(swf);
				*/
				
				var swfWriter:AsyncSWFWriter = new AsyncSWFWriter();
				swfWriter.addEventListener(AsyncSWFWriterEvent.TAG_WRITTEN, function(ev:AsyncSWFWriterEvent):void
				{
					trace('Tag written');
				});
				
				swfWriter.addEventListener(AsyncSWFWriterEvent.WRITE_COMPLETE, function(ev:AsyncSWFWriterEvent):void
				{
					diff = getTimer() - start;
					
					trace('Writing swf took: '+diff+'ms');
					logOut.text += 'Writing swf took: '+diff+'ms\n';
					
					var result:SWFWriteResult = ev.result;
					
					Debug.dump(result, 4);
					
					preview.setSWFBackground(backgroundColor);
					preview.setSWFSize((swf.header.frameSize.xMax - swf.header.frameSize.xMin)/20, (swf.header.frameSize.yMax - swf.header.frameSize.yMin)/20);
					
					//var f:File = new File(File.applicationDirectory.nativePath).resolvePath('recompiled.swf');
					var f:File = new File(File.applicationDirectory.nativePath).resolvePath(lastUrl+'.recompiled.'+lastFileSize+'.swf');
					trace(f.nativePath);
					var fs:FileStream = new FileStream();
					fs.open(f, FileMode.WRITE);
					fs.writeBytes(result.bytes);
					fs.close();
					
					run(result.bytes);
				});

				swfWriter.write(swf);
			}
				
			private var lastRunBytes:ByteArray;
			
			private function run(bytes:ByteArray):void
			{
				currentState = 'loaded';

				lastRunBytes = bytes;
				var context:LoaderContext = new LoaderContext();
				context.allowCodeImport = true;
				context.applicationDomain = new ApplicationDomain(injectedAppDomain);
				preview.loadBytes(bytes, context);
			}
			
			private var lastFileSize:uint;
			
			public function load(url:String):void
			{
				var orig:File = File.applicationDirectory.resolvePath(url);
				
				lastUrl = url;
				
				lastFileSize = orig.size;
				
				var newUrl:String = url+'.recompiled.'+orig.size+'.swf';
				var f:File = File.applicationDirectory.resolvePath(newUrl);
				if(f.exists && cacheEnabled)
				{
					url = newUrl;
					isCached = true;
				}
				else
				{
					isCached = false;
				}
				
				currentState = 'loading';
				
				loadProgress.setProgress(0, 0);
				readProgress.setProgress(0, 0);
				writeProgress.setProgress(0, 0);
				urlLoader.load(new URLRequest(url));
			}

			protected function showMethodEntry_clickHandler(event:MouseEvent):void
			{
				logger.showMethodEntry = showMethodEntry.selected;
			}

			protected function showMethodExit_clickHandler(event:MouseEvent):void
			{
				logger.showMethodExit = showMethodExit.selected;
			}

			protected function dumpArguments_clickHandler(event:MouseEvent):void
			{
				logger.showArguments = dumpArguments.selected;
			}

			protected function showTrace_clickHandler(event:MouseEvent):void
			{
				logger.showTrace = showTrace.selected;
			}

			protected function logToOutput_clickHandler(event:MouseEvent):void
			{
				logger.logToOutput = logToOutput.selected;
			}

			protected function showReturn_clickHandler(event:MouseEvent):void
			{
				logger.showReturn = showReturn.selected;
			}

			protected function button1_clickHandler(event:MouseEvent):void
			{
				logOut.text = '';
			}

			protected function button2_clickHandler(event:MouseEvent):void
			{
				run(lastRunBytes);
			}
			
			protected function startInspection():void
			{
				inspectButton.selected = true;
				preview.loader.mouseEnabled = false;
				preview.loader.mouseChildren = false;
				preview.addEventListener(MouseEvent.MOUSE_MOVE, inspectHandler);
				preview.addEventListener(MouseEvent.MOUSE_UP, inspect_mouseUpHandler);
				preview.clearOverlay();
			}
			
			protected function stopInspection():void
			{
				inspectButton.selected = false;
				preview.removeEventListener(MouseEvent.MOUSE_UP, inspect_mouseUpHandler);
				preview.removeEventListener(MouseEvent.MOUSE_MOVE, inspectHandler);
				preview.loader.mouseChildren = true;
				preview.loader.mouseEnabled = true;
				preview.clearOverlay();
			}
			
			protected function inspect_mouseUpHandler(ev:MouseEvent):void
			{
				stopInspection();
			}

			protected function logToTrace_clickHandler(event:MouseEvent):void
			{
				logger.logToTrace = logToTrace.selected;
			}

			protected function inspectGrid_keyDownHandler(event:KeyboardEvent):void
			{
				trace('key: '+event.keyCode);
			}

		]]>
	</mx:Script>
	<mx:states>
		<mx:State name="waiting">
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{loadProgress}"/>
			<mx:RemoveChild target="{readProgress}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{systemLog}"/>
		</mx:State>
		<mx:State name="loading">
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{readProgress}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{canvas1}"/>
		</mx:State>
		<mx:State name="reading">
			<mx:RemoveChild target="{canvas1}"/>
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{loadProgress}"/>
		</mx:State>
		<mx:State name="writing">
			<mx:RemoveChild target="{canvas1}"/>
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{loadProgress}"/>
			<mx:RemoveChild target="{readProgress}"/>
		</mx:State>
		<mx:State name="loaded">
			<mx:RemoveChild target="{loadProgress}"/>
			<mx:RemoveChild target="{readProgress}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{canvas1}"/>
			<mx:RemoveChild target="{systemLog}"/>
			<mx:SetStyle target="{hbox1}" name="verticalAlign" value="middle"/>
		</mx:State>
	</mx:states>
	<mx:HBox id="header" width="100%">
		<mx:Spacer width="100%"/>
		<mx:Image source="@Embed('logo.png')"/>
	</mx:HBox>
	<ui:BreadCrumb id="breadCrumb" width="100%" height="26"/>
	<mx:Canvas width="100%" height="100%" id="canvas1">
		<mx:VBox horizontalCenter="0" verticalCenter="0" horizontalAlign="center">
			<mx:Label text="Drop File on Logo" styleName="bigText"/>
			<!--<mx:CheckBox id="useCached" label="Use Cached"/>-->
		</mx:VBox>
	</mx:Canvas>
	<mx:TextArea id="systemLog" editable="false" width="100%" height="100%" text="Debug info goes here."/>
	<mx:HDividedBox width="100%" height="100%" id="hdividedbox1">
		<mx:VDividedBox width="100%" height="100%">
			<mx:HDividedBox width="100%" height="100%">
				<ui:PreviewPanel id="preview" width="100%" height="100%"/>
				<mx:VBox width="400" height="100%" verticalGap="0">
					<mx:Label id="inspectType" width="100%"/>
					<mx:DataGrid id="inspectGrid" width="100%" height="100%" editable="true"
								 itemEditEnd="inspectGrid_itemEditEndHandler(event)"
								 keyDown="inspectGrid_keyDownHandler(event)">
						<mx:columns>
							<mx:DataGridColumn headerText="Name" dataField="name" editable="false" width="180"/>
							<mx:DataGridColumn headerText="Value" dataField="value" editable="true"/>
						</mx:columns>
					</mx:DataGrid>
				</mx:VBox>
			</mx:HDividedBox>
			<mx:VBox width="100%" height="100%">
				<mx:HBox height="40">
					<mx:Button id="reloadButton" label="Reload" click="button2_clickHandler(event)" height="100%"/>
					<mx:Button id="resetButton" label="Reset Position" click="preview.resetSWFPosition()" height="100%"/>
					<mx:Button id="inspectButton" label="Inspect" click="startInspection()" height="100%"/>
					<mx:Button label="Clear Console" click="button1_clickHandler(event)" height="100%"/>
				</mx:HBox>
				<mx:HBox width="100%" height="100%">
					<mx:VBox height="100%">
						<mx:CheckBox id="logToOutput" label="Log to output" click="logToOutput_clickHandler(event)" styleName="smallText"/>
						<mx:CheckBox id="logToTrace" label="Log to trace" click="logToTrace_clickHandler(event)" styleName="smallText"/>
						<mx:CheckBox id="showMethodEntry" label="Show method entry" click="showMethodEntry_clickHandler(event)" styleName="smallText"/>
						<mx:CheckBox id="showMethodExit" label="Show method exit" click="showMethodExit_clickHandler(event)" styleName="smallText"/>
						<mx:CheckBox id="showTrace" label="Show trace" click="showTrace_clickHandler(event)" styleName="smallText"/>
						<mx:CheckBox id="dumpArguments" label="Show arguments" click="dumpArguments_clickHandler(event)" styleName="smallText"/>
						<mx:CheckBox id="showReturn" label="Show return values" click="showReturn_clickHandler(event)" styleName="smallText"/>
						<mx:HBox id="hbox1">
							<mx:Label text="Max Stack Depth:" styleName="smallText"/>
							<mx:NumericStepper id="maxStackDepth" value="10"/>
						</mx:HBox>
					</mx:VBox>
					<mx:TextArea id="logOut" width="100%" height="100%" editable="false" fontFamily="Courier New" fontSize="11"/>
				</mx:HBox>
			</mx:VBox>
		</mx:VDividedBox>
	</mx:HDividedBox>
	<mx:ProgressBar id="loadProgress" width="100%" mode="manual" label="Loading SWF: %3%%" styleName="bigText"/>
	<mx:ProgressBar id="readProgress" width="100%" mode="manual" label="Reading SWF: %3%%" styleName="bigText"/>
	<mx:ProgressBar id="writeProgress" width="100%" mode="manual" label="Writing SWF: %3%%" styleName="bigText"/>
</mx:WindowedApplication>
