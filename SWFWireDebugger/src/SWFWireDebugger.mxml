<?xml version="1.0" encoding="utf-8"?>
<mx:WindowedApplication xmlns:mx="http://www.adobe.com/2006/mxml" 
						xmlns:ui="com.swfwire.debugger.flex.ui.*"
						showStatusBar="false"
						applicationComplete="main()"
						minWidth="400" minHeight="300"
						paddingLeft="5" paddingTop="5"
						horizontalAlign="right"
						currentState="waiting" backgroundColor="#222222">
	<mx:Style source="style.css"/>
	<mx:Script>
		<![CDATA[
			import air.update.ApplicationUpdaterUI;
			
			import com.swfwire.debugger.utils.*;
			import com.swfwire.decompiler.*;
			import com.swfwire.decompiler.abc.ABCReaderMetadata;
			import com.swfwire.decompiler.abc.instructions.*;
			import com.swfwire.decompiler.abc.tokens.*;
			import com.swfwire.decompiler.abc.tokens.multinames.MultinameQNameToken;
			import com.swfwire.decompiler.abc.tokens.traits.TraitMethodToken;
			import com.swfwire.decompiler.data.swf.SWF;
			import com.swfwire.decompiler.data.swf.SWFHeader;
			import com.swfwire.decompiler.data.swf.tags.SetBackgroundColorTag;
			import com.swfwire.decompiler.data.swf9.tags.DoABCTag;
			import com.swfwire.decompiler.data.swf9.tags.SymbolClassTag;
			import com.swfwire.decompiler.events.AsyncSWFReaderEvent;
			import com.swfwire.utils.Debug;
			import com.swfwire.utils.air.WindowTracker;
			
			import mx.controls.Alert;
			import mx.core.IUIComponent;
			import mx.managers.DragManager;
			
			private var windowTracker:WindowTracker;
			private var appUpdater:ApplicationUpdaterUI;
			private var urlLoader:URLLoader;
			
			private var logger:*;
			private var injectedAppDomain:ApplicationDomain;
			private var lastUrl:String;
			private var isCached:Boolean;
			
			private var sanityCheck:Boolean = false;
			private var cacheEnabled:Boolean = false;
			
			private function main():void
			{
				logOut.text = 'Version '+Config.VERSION+'\n';
				
				stage.addEventListener(Event.ENTER_FRAME, function(ev:*):void
				{
					if(logger)
					{
						logger.enterFrame();
					}
				});
				
				loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, function(ev:UncaughtErrorEvent):void
				{
					ev.preventDefault();
					ev.stopPropagation();
					ev.stopImmediatePropagation();
					logger.uncaughtError(ev.error);
				}, true);
				
				appUpdater = new ApplicationUpdaterUI();
				appUpdater.configurationFile = new File('app:/updateConfig.xml');
				appUpdater.initialize();
				
				windowTracker = new WindowTracker(SharedObject.getLocal('preferences'), nativeWindow);
				windowTracker.restore();
				windowTracker.startTracking();
				
				urlLoader = new URLLoader();
				urlLoader.addEventListener(ProgressEvent.PROGRESS,	 loadProgressHandler);
				urlLoader.addEventListener(Event.COMPLETE,			 loadCompleteHandler);
				urlLoader.dataFormat = URLLoaderDataFormat.BINARY;
				
				header.addEventListener(NativeDragEvent.NATIVE_DRAG_ENTER,	 dragEnterHandler);
				header.addEventListener(NativeDragEvent.NATIVE_DRAG_DROP,	 dragDropHandler);
				
				preview.addEventListener(MouseEvent.CONTEXT_MENU, inspectHandler);
				preview.addEventListener('loaderComplete', function(ev:Event):void
				{
					if(!sanityCheck)
					{
						var a:* = preview.loader.content;
						a.deferredConstructor();
						preview.invalidateDisplayList();
						preview.validateDisplayList();
					}
				});
				
				Debug.enabled = true;
				
				var context:LoaderContext = new LoaderContext();
				context.applicationDomain = new ApplicationDomain();
				context.allowCodeImport = true;
				
				injectionLoader = new Loader();
				injectionLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(ev:*):void
				{
					injectedAppDomain = injectionLoader.contentLoaderInfo.applicationDomain;
					
					logOut.text += 'Injection loaded\n';
					
					logger = injectedAppDomain.getDefinition('com.swfwire.debugger.injected.Logger');
					logger.output = logOut;
					logToTrace.selected = logger.logToTrace;
					logToOutput.selected = logger.logToOutput;
					logToTrace.selected = logger.logToTrace;
					showMethodEntry.selected = logger.showMethodEntry;
					showMethodExit.selected = logger.showMethodExit;
					showTrace.selected = logger.showTraceStatements;
					dumpArguments.selected = logger.showArguments;
					showReturn.selected = logger.showReturn;
					
					//injectedAppDomain.getDefinition('com.swfwire.debugger.injected').output = logOut;
					//loadDefault();
				});
				
				var librarySwf:String = new File(File.applicationDirectory.nativePath).resolvePath('library.swf?nocache='+Math.random()).url;
				
				injectionLoader.load(new URLRequest(librarySwf), context);
				//loadDefault();
			}
			
			private function swfwireRel(url:String):String
			{
				return new File(File.applicationDirectory.nativePath).parent.parent.resolvePath(url).url;				
			}
			
			private var injectionLoader:Loader;
			
			private function loadDefault():void
			{
				
				//load(new File(File.applicationDirectory.nativePath).parent.parent.resolvePath('SWFCorpseFlex4-1/bin-debug/Main.swf').url);
				load(new File(File.applicationDirectory.nativePath).parent.parent.resolvePath('SWFCorpse/bin-debug/SWFCorpse.swf').url);
				//load(new File(File.applicationDirectory.nativePath).parent.parent.resolvePath('SWFWireInspector/bin-debug/SWFWireInspector.swf').url);
				//load(new File(File.applicationDirectory.nativePath).parent.parent.resolvePath('SWFCorpseFlex3-5/bin-debug/Main.swf').url);
				//load('temp.swf');
				//load('SlowMoPlayer.swf');
				//load('cs5-5_pfflib.swf');
				//load('frees.swf');
			}
			
			private function inspectHandler(ev:MouseEvent):void
			{
				var point:Point = preview.localToGlobal(new Point(preview.mouseX, preview.mouseY));
				
				var objects:Array = preview.getObjectsUnderPoint(point);
				//objects.shift();
				
				var target:DisplayObject = objects[0];
				
				var path:Array = [];
				var currentTarget:DisplayObject = target;
				
				while(currentTarget && currentTarget.parent)
				{
					path.push(currentTarget.name);
					currentTarget = currentTarget.parent;
				}
				
				inspectOut.text += path.reverse().join('.')+'\n';
				
				Debug.dump(objects, 2);
				//trace(objects.join('\n'));
			}
			
			private function loadProgressHandler(ev:ProgressEvent):void
			{
				loadProgress.setProgress(ev.bytesLoaded, ev.bytesTotal);
			}
			
			private function loadCompleteHandler(ev:Event):void
			{
				var bytes:ByteArray = urlLoader.data as ByteArray;
				if(bytes)
				{
					if(isCached || sanityCheck)
					{
						readProgress.setProgress(1, 1);
						writeProgress.setProgress(1, 1);
						run(bytes);
						/*
						var context:LoaderContext = new LoaderContext();
						context.allowLoadBytesCodeExecution = true;
						//context.applicationDomain = new ApplicationDomain();
						context.applicationDomain = new ApplicationDomain(injectedAppDomain);
						preview.loadBytes(bytes, context);
						preview.loader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(ev:*):void
						{
							var temp:* = preview.loader.contentLoaderInfo.applicationDomain.hasDefinition('com.swfwire.debugger.injected.Logger');
							Debug.dump({temp: temp});
						});
						*/
					}
					else
					{
						parse(bytes);
					}
				}
			}
			
			private function dragEnterHandler(ev:NativeDragEvent):void
			{
				DragManager.acceptDragDrop(IUIComponent(ev.currentTarget));
			}
			
			private function dragDropHandler(ev:NativeDragEvent):void
			{
				var clipboard:Clipboard = ev.clipboard;
				var url:String = '';
				if(clipboard.hasFormat(ClipboardFormats.URL_FORMAT))
				{
					url = clipboard.getData(ClipboardFormats.URL_FORMAT) as String;
				}
				else if(clipboard.hasFormat(ClipboardFormats.TEXT_FORMAT))
				{
					url = clipboard.getData(ClipboardFormats.TEXT_FORMAT) as String;
				}
				else if(clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
				{
					var files:Array = clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array;
					var file:File = files[0];
					if(file)
					{
						url = file.url;
					}
				}
				if(url)
				{
					currentState = 'loading';
					load(url);
				}
				else
				{
					Alert.show('Could not parse any valid SWF file from the drop.', 'No data');
				}
			}
			
			private function parse(bytes:ByteArray):void
			{
				currentState = 'reading';

				var swfBytes:SWFByteArray = new SWFByteArray(bytes);
				var swfReader:AsyncSWFReaderFiltered = new AsyncSWFReaderFiltered();
				var result:SWFReadResult;
				
				swfReader.includedTags[0] = true;
				swfReader.includedTags[76] = true;
				swfReader.includedTags[82] = true;
				swfReader.addEventListener(AsyncSWFReaderEvent.TAG_READ, function(ev:Event):void
				{
					var current:uint = swfBytes.getBytePosition();
					var max:uint = swfBytes.getLength();
					readProgress.setProgress(current, max);
				});
				swfReader.addEventListener(AsyncSWFReaderEvent.READ_COMPLETE, function(ev:Event):void
				{
					inject(result.swf, result.abcMetadata);
				});
				
				result = swfReader.read(swfBytes);
			}
			
			private function inject(swf:SWF, metadata:Vector.<ABCReaderMetadata>):void
			{
				var start:uint = getTimer();
				
				swf.header.signature = SWFHeader.UNCOMPRESSED_SIGNATURE;
				
				var mainClass:String = '';
				var iTag:uint;
				
				var backgroundColor:uint = 0xFFFFFF;
				
				outer:
				for(iTag = 0; iTag < swf.tags.length; iTag++)
				{
					var bgt:SetBackgroundColorTag = swf.tags[iTag] as SetBackgroundColorTag;
					if(bgt)
					{
						backgroundColor = bgt.backgroundColor.red << 16 | bgt.backgroundColor.green << 8 | bgt.backgroundColor.blue;
					}
					var sct:SymbolClassTag = swf.tags[iTag] as SymbolClassTag;
					if(sct)
					{
						for(var isym:uint = 0; isym < sct.symbols.length; isym++)
						{
							if(sct.symbols[isym].characterId == 0)
							{
								mainClass = sct.symbols[isym].className;
								break outer;
							}
						}
					}
				}
				
				trace('main class: '+mainClass);
				
				var mainClassPackage:String = '';
				var mainClassName:String = mainClass;
				
				if(mainClass.indexOf('.') >= 0)
				{
					mainClassName = mainClass.substr(mainClass.lastIndexOf('.') + 1);
					mainClassPackage = mainClass.substr(0, mainClass.lastIndexOf('.'));
				}
				
				for(iTag = 0; iTag < swf.tags.length; iTag++)
				{
					var abcTag:DoABCTag = swf.tags[iTag] as DoABCTag;
					if(abcTag)
					{
						var wrapper:ABCWrapper = new ABCWrapper(abcTag.abcFile, metadata[iTag]);
						
						var securityIndex:int = wrapper.getMultinameIndex('flash.system', 'Security');
						if(securityIndex >= 0)
						{
							var security:MultinameQNameToken = abcTag.abcFile.cpool.multinames[securityIndex].data as MultinameQNameToken;
							var injectedNamespace:uint = wrapper.addNamespaceFromString('com.swfwire.debugger.injected'); 
							security.ns = injectedNamespace;
							//abcTag.abcFile.cpool.namespaces[security.ns].name = wrapper.addString('com.swfwire.debugger.injected');
						}
						
						var mainIndex:int = wrapper.getMultinameIndex(mainClassPackage, mainClassName);
						var mainInst:InstanceToken = null;
						
						if(mainIndex >= 0)
						{
							for(var i:uint = 0; i < abcTag.abcFile.instances.length; i++)
							{
								var inst:InstanceToken = abcTag.abcFile.instances[i];
								if(inst.name == mainIndex)
								{
									mainInst = inst;
									break;
								}
							}
						}
						
						if(mainInst)
						{
							var defcm:MethodInfoToken = new MethodInfoToken();
							defcm.name = wrapper.addString(mainClass+'/deferredConstructor');
							
							var defcmi:uint = abcTag.abcFile.methods.push(defcm) - 1;
							
							var defcmni:int = wrapper.addQName(
								wrapper.addNamespaceFromString(''), 
								wrapper.addString('deferredConstructor'));

							var mainTrait:TraitsInfoToken = new TraitsInfoToken(defcmni,
								TraitsInfoToken.KIND_TRAIT_METHOD,
								0,
								new TraitMethodToken(0, defcmi));
							
							//Debug.log('test', 'before', mainInst.traits);
							
							mainInst.traits.push(mainTrait);
							//mainInst.traits[10].name = fmi;
							//abcTag.abcFile.methods[mainInst.iinit].
							
							var emptyMethod:MethodBodyInfoToken = new MethodBodyInfoToken(
								mainInst.iinit, 1, 1, 9, 10);
							emptyMethod.instructions = wrapper.getEmptyConstructorInstructions();
							
							abcTag.abcFile.methodBodies.push(emptyMethod);
							
							var mainMB:MethodBodyInfoToken = wrapper.findMethodBody(mainInst.iinit);
							mainMB.method = defcmi;
							
							//mainInst.iinit = fci;
						}
						
						//Debug.log('test', 'after', mainInst.traits);
						
						//mainInst.iinit--;
						
						if(true)
						{
							var loggerClassIndex:int = wrapper.addQName(
								wrapper.addNamespaceFromString('com.swfwire.debugger.injected'), 
								wrapper.addString('Logger'));
							
							var emptyNS:int = wrapper.addNamespaceFromString('');
							
							var enterFunctionIndex:int = wrapper.addQName(emptyNS, wrapper.addString('enterFunction'));
							var exitFunctionIndex:int = wrapper.addQName(emptyNS, wrapper.addString('exitFunction'));
							
							var cp:ConstantPoolToken = abcTag.abcFile.cpool;
							
							var traceIndex:int = wrapper.getMultinameIndex('', 'trace');
							if(traceIndex >= 0)
							{
								var l:* = wrapper.findInstruction(new InstructionTemplate(Instruction_findpropstrict, {index: traceIndex}));
								
								for(var iter:* in l)
								{
									abcTag.abcFile.methodBodies[l[iter].methodBody].maxStack += 1;
								}
								
								wrapper.replaceInstruction2(l, function(z:*, a:Vector.<IInstruction>):Vector.<IInstruction>
								{
									var b:Vector.<IInstruction> = new Vector.<IInstruction>();
									b.push(new Instruction_getlex(loggerClassIndex));
									return b;
								});
							
								var methodIndex:int = wrapper.addQName(emptyNS, wrapper.addString('log'));
								
								l = wrapper.findInstruction(new InstructionTemplate(Instruction_callpropvoid, {index: traceIndex}));
								wrapper.replaceInstruction2(l, function(z:*, a:Vector.<IInstruction>):Vector.<IInstruction>
								{
									var b:Vector.<IInstruction> = new Vector.<IInstruction>();
									b.push(new Instruction_callpropvoid(methodIndex, Object(a[0]).argCount));
									return b;
								});
								
								l = wrapper.findInstruction(new InstructionTemplate(Instruction_callproperty, {index: traceIndex}));
								wrapper.replaceInstruction2(l, function(z:*, a:Vector.<IInstruction>):Vector.<IInstruction>
								{
									var b:Vector.<IInstruction> = new Vector.<IInstruction>();
									b.push(new Instruction_callproperty(methodIndex, Object(a[0]).argCount));
									return b;
								});
							}
							
							var nameFromMethodId:Object = {};
							
							function qnameToString(index:uint):String
							{
								var result:String = '<Not a QName>';
								var mq:MultinameQNameToken = cp.multinames[index].data as MultinameQNameToken;
								if(mq)
								{
									var ns:String = cp.strings[cp.namespaces[mq.ns].name].utf8;
									if(ns != '')
									{
										ns = ns + '::';
									}
									result = ns + cp.strings[mq.name].utf8;
								}
								return result;
							}
							
							
							for(var i11:int = 0; i11 < abcTag.abcFile.instances.length; i11++)
							{
								var inst2:InstanceToken = abcTag.abcFile.instances[i11];
								
								var instName:String = qnameToString(inst2.name);
								
								nameFromMethodId[inst2.iinit] = instName;
								for(var i12:int = 0; i12 < inst2.traits.length; i12++)
								{
									var name:String = qnameToString(inst2.traits[i12].name);
									var tmt:TraitMethodToken = inst2.traits[i12].data as TraitMethodToken;
									if(tmt)
									{
										nameFromMethodId[tmt.methodId] = instName+'/'+name;
									}
								}
							}
							
							for(var i13:int = 0; i13 < abcTag.abcFile.classes.length; i13++)
							{
								var classInfo:ClassInfoToken = abcTag.abcFile.classes[i13];
								var inst3:InstanceToken = abcTag.abcFile.instances[i13];
								
								var className:String = qnameToString(inst3.name);
								
								nameFromMethodId[classInfo.cinit] = className+'$cinit';
								
								for(var i14:int = 0; i14 < classInfo.traits.length; i14++)
								{
									var name2:String = qnameToString(classInfo.traits[i14].name);
									var tmt2:TraitMethodToken = classInfo.traits[i14].data as TraitMethodToken;
									if(tmt2)
									{
										nameFromMethodId[tmt2.methodId] = className+'$/'+name2;
									}
								}
							}
							
							for(var i9:int = 0; i9 < abcTag.abcFile.methodBodies.length; i9++)
							{
								var mb:MethodBodyInfoToken = abcTag.abcFile.methodBodies[i9];
								if(mb.initScopeDepth > 1)
								{
									var j9:* = abcTag.abcFile.methodBodies[i9].instructions;
									
									var paramCount:uint = abcTag.abcFile.methods[mb.method].paramCount;

									
									j9.unshift(new Instruction_callpropvoid(enterFunctionIndex, 3));
									
									if(paramCount > 0)
									{
										abcTag.abcFile.methodBodies[i9].maxStack += paramCount * 2 + 3;
										j9.unshift(new Instruction_newobject(paramCount));
	
										for(var i10:int = paramCount - 1; i10 >= 0; i10--)
										{
											var paramName:ParamInfoToken = abcTag.abcFile.methods[mb.method].paramNames[i10];
											j9.unshift(new Instruction_getlocal(i10 + 1));
											if(paramName && paramName.value > 0)
											{
												j9.unshift(new Instruction_pushstring(paramName.value));
											}
											else
											{
												j9.unshift(new Instruction_pushstring(wrapper.addString('param'+i10)));
											}
										}
									}
									else
									{
										abcTag.abcFile.methodBodies[i9].maxStack += 4;
										j9.unshift(new Instruction_pushnull());
									}
									
									j9.unshift(new Instruction_getlocal0());
									
									var methodId:int =  wrapper.addString(iTag+'.'+String(i9));
									var methodName:String = nameFromMethodId[mb.method];// abcTag.abcFile.methods[mb.method].name;
									if(methodName)
									{
										methodId =  wrapper.addString(methodName);
									}
									j9.unshift(new Instruction_pushstring(methodId));
									/*
									var methodId:int =  wrapper.addString(iTag+'.'+String(i9));
									j9.unshift(new Instruction_pushstring(methodId));
									*/
									j9.unshift(new Instruction_getlex(loggerClassIndex));
								}
							}
							
							l = wrapper.findInstruction(new InstructionTemplate(Instruction_returnvoid, {}));
							
							for(var iter6:* in l)
							{
								abcTag.abcFile.methodBodies[l[iter6].methodBody].maxStack += 1;
							}
							
							wrapper.replaceInstruction2(l, function(z:InstructionLocation, a:Vector.<IInstruction>):Vector.<IInstruction>
							{
								var mb:MethodBodyInfoToken = abcTag.abcFile.methodBodies[z.methodBody];
								if(mb.initScopeDepth > 1)
								{
									a.unshift(new Instruction_callpropvoid(exitFunctionIndex, 1));
									
									var methodId:int =  wrapper.addString(iTag+'.'+z.methodBody);
									var methodName:String = nameFromMethodId[mb.method];
									if(methodName)
									{
										methodId =  wrapper.addString(methodName);
									}
									a.unshift(new Instruction_pushstring(methodId));

									//var j7:int =  wrapper.addString(iTag+'.'+String(z.methodBody));
									//a.unshift(new Instruction_pushstring(j7));
									a.unshift(new Instruction_getlex(loggerClassIndex));
								}
								wrapper.redirectReferences(z.methodBody, a[a.length - 1], a[0]);
								return a;
							});
							
							l = wrapper.findInstruction(new InstructionTemplate(Instruction_returnvalue, {}));
							
							for(iter6 in l)
							{
								abcTag.abcFile.methodBodies[l[iter6].methodBody].maxStack += 1;
							}
							
							wrapper.replaceInstruction2(l, function(z:InstructionLocation, a:Vector.<IInstruction>):Vector.<IInstruction>
							{
								var mb:MethodBodyInfoToken = abcTag.abcFile.methodBodies[z.methodBody];
								if(mb.initScopeDepth > 1)
								{
									a.unshift(new Instruction_callpropvoid(exitFunctionIndex, 2));
									a.unshift(new Instruction_swap());
									
									var methodId:int =  wrapper.addString(iTag+'.'+z.methodBody);
									var methodName:String = nameFromMethodId[mb.method];
									if(methodName)
									{
										methodId =  wrapper.addString(methodName);
									}
									a.unshift(new Instruction_pushstring(methodId));

									//var j8:int =  wrapper.addString(iTag+'.'+String(z.methodBody));
									//a.unshift(new Instruction_pushstring(j8));
									a.unshift(new Instruction_swap());
									a.unshift(new Instruction_getlex(loggerClassIndex));
									a.unshift(new Instruction_dup());
								}
								wrapper.redirectReferences(z.methodBody, a[a.length - 1], a[0]);
								return a;
							});
						}
					}
				}
				
				var diff:uint = getTimer() - start;
				
				trace('Modifying swf took: '+diff+'ms');
				logOut.text += 'Modifying swf took: '+diff+'ms\n';
				
				start = getTimer();

				var swfWriter:SWF10Writer = new SWF10Writer();
				
				var result:SWFWriteResult = swfWriter.write(swf);
				
				writeProgress.setProgress(1, 1);
				
				diff = getTimer() - start;
				
				trace('Writing swf took: '+diff+'ms');
				logOut.text += 'Writing swf took: '+diff+'ms\n';
				
				Debug.dump(result, 4);
				
				preview.setStyle('backgroundColor', backgroundColor);
				
				//var f:File = new File(File.applicationDirectory.nativePath).resolvePath('recompiled.swf');
				var f:File = new File(File.applicationDirectory.nativePath).resolvePath(lastUrl+'.recompiled.'+lastFileSize+'.swf');
				trace(f.nativePath);
				var fs:FileStream = new FileStream();
				fs.open(f, FileMode.WRITE);
				fs.writeBytes(result.bytes);
				fs.close();
				
				run(result.bytes);
			}
			
			private var lastRunBytes:ByteArray;
			
			private function run(bytes:ByteArray):void
			{
				currentState = 'loaded';

				lastRunBytes = bytes;
				var context:LoaderContext = new LoaderContext();
				context.allowCodeImport = true;
				context.applicationDomain = new ApplicationDomain(injectedAppDomain);
				preview.loadBytes(bytes, context);
			}
			
			private var lastFileSize:uint;
			
			public function load(url:String):void
			{
				var orig:File = File.applicationDirectory.resolvePath(url);
				
				lastUrl = url;
				
				lastFileSize = orig.size;
				
				var newUrl:String = url+'.recompiled.'+orig.size+'.swf';
				var f:File = File.applicationDirectory.resolvePath(newUrl);
				if(f.exists && cacheEnabled)
				{
					url = newUrl;
					isCached = true;
				}
				else
				{
					isCached = false;
				}
				
				currentState = 'loading';
				
				loadProgress.setProgress(0, 0);
				readProgress.setProgress(0, 0);
				writeProgress.setProgress(0, 0);
				urlLoader.load(new URLRequest(url));
			}

			protected function showMethodEntry_clickHandler(event:MouseEvent):void
			{
				logger.showMethodEntry = showMethodEntry.selected;
			}

			protected function showMethodExit_clickHandler(event:MouseEvent):void
			{
				logger.showMethodExit = showMethodExit.selected;
			}

			protected function dumpArguments_clickHandler(event:MouseEvent):void
			{
				logger.showArguments = dumpArguments.selected;
			}

			protected function showTrace_clickHandler(event:MouseEvent):void
			{
				logger.showTrace = showTrace.selected;
			}

			protected function logToOutput_clickHandler(event:MouseEvent):void
			{
				logger.logToOutput = logToOutput.selected;
			}

			protected function showReturn_clickHandler(event:MouseEvent):void
			{
				logger.showReturn = showReturn.selected;
			}

			protected function button1_clickHandler(event:MouseEvent):void
			{
				logOut.text = '';
			}

			protected function button2_clickHandler(event:MouseEvent):void
			{
				run(lastRunBytes);
			}

			protected function logToTrace_clickHandler(event:MouseEvent):void
			{
				logger.logToTrace = logToTrace.selected;
			}

		]]>
	</mx:Script>
	<mx:states>
		<mx:State name="waiting">
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{loadProgress}"/>
			<mx:RemoveChild target="{readProgress}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{systemLog}"/>
		</mx:State>
		<mx:State name="loading">
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{readProgress}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{canvas1}"/>
		</mx:State>
		<mx:State name="reading">
			<mx:RemoveChild target="{canvas1}"/>
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{loadProgress}"/>
		</mx:State>
		<mx:State name="writing">
			<mx:RemoveChild target="{canvas1}"/>
			<mx:RemoveChild target="{hdividedbox1}"/>
			<mx:RemoveChild target="{loadProgress}"/>
			<mx:RemoveChild target="{readProgress}"/>
		</mx:State>
		<mx:State name="loaded">
			<mx:RemoveChild target="{loadProgress}"/>
			<mx:RemoveChild target="{readProgress}"/>
			<mx:RemoveChild target="{writeProgress}"/>
			<mx:RemoveChild target="{canvas1}"/>
			<mx:RemoveChild target="{systemLog}"/>
			<mx:SetStyle target="{hbox1}" name="verticalAlign" value="middle"/>
		</mx:State>
	</mx:states>
	<mx:HBox id="header" width="100%">
		<mx:Button label="Reload" click="button2_clickHandler(event)" height="100%"/>
		<mx:Spacer width="100%"/>
		<mx:Image source="@Embed('logo.png')"/>
	</mx:HBox>
	<mx:Canvas width="100%" height="100%" id="canvas1">
		<mx:VBox horizontalCenter="0" verticalCenter="0" horizontalAlign="center">
			<mx:Label text="Drop File Here" styleName="bigText"/>
			<mx:CheckBox id="useCached" label="Use Cached"/>
		</mx:VBox>
	</mx:Canvas>
	<mx:TextArea id="systemLog" editable="false" width="100%" height="100%" text="Debug info goes here."/>
	<mx:HDividedBox width="100%" height="100%" id="hdividedbox1">
		<mx:VDividedBox width="100%" height="100%">
			<mx:HDividedBox width="100%" height="100%">
				<mx:VBox width="100%" height="100%">
					<ui:PreviewPanel id="preview" width="100%" height="100%"/>
				</mx:VBox>
				<mx:TextArea id="inspectOut" width="300" height="100%"/>
			</mx:HDividedBox>
			<mx:HDividedBox width="100%">
				<mx:VBox height="100%">
					<mx:CheckBox id="logToOutput" label="Log to output" click="logToOutput_clickHandler(event)" styleName="smallText"/>
					<mx:CheckBox id="logToTrace" label="Log to trace" click="logToTrace_clickHandler(event)" styleName="smallText"/>
					<mx:CheckBox id="showMethodEntry" label="Show method entry" click="showMethodEntry_clickHandler(event)" styleName="smallText"/>
					<mx:CheckBox id="showMethodExit" label="Show method exit" click="showMethodExit_clickHandler(event)" styleName="smallText"/>
					<mx:CheckBox id="showTrace" label="Show trace" click="showTrace_clickHandler(event)" styleName="smallText"/>
					<mx:CheckBox id="dumpArguments" label="Show arguments" click="dumpArguments_clickHandler(event)" styleName="smallText"/>
					<mx:CheckBox id="showReturn" label="Show return values" click="showReturn_clickHandler(event)" styleName="smallText"/>
					<mx:HBox id="hbox1">
						<mx:Label text="Max Stack Depth:" styleName="smallText"/>
						<mx:NumericStepper id="maxStackDepth" value="10"/>
					</mx:HBox>
					<mx:Spacer height="100%"/>
					<mx:Button label="Clear" click="button1_clickHandler(event)"/>
				</mx:VBox>
				<mx:TextArea id="logOut" width="100%" height="100%" editable="false" fontFamily="Courier New" fontSize="11"/>
			</mx:HDividedBox>
		</mx:VDividedBox>
	</mx:HDividedBox>
	<mx:ProgressBar id="loadProgress" width="100%" mode="manual" label="Loading SWF: %3%%" styleName="bigText"/>
	<mx:ProgressBar id="readProgress" width="100%" mode="manual" label="Reading SWF: %3%%" styleName="bigText"/>
	<mx:ProgressBar id="writeProgress" width="100%" mode="manual" label="Writing SWF: %3%%" styleName="bigText"/>
</mx:WindowedApplication>
